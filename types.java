/** GENERATED BY BENDEC TYPE GENERATOR */

import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

class Utils {

    public static byte[] uInt8ToByteArray(int value) {
        return new byte[]{(byte) (value & 0xFF)};
    }

    public static byte[] uInt16ToByteArray(int value) {
        return new byte[]{
                (byte) ((value >>> 8) & 0xFF),
                (byte) (value & 0xFF)
        };
    }

    public static byte[] uInt32ToByteArray(long value) {
        return new byte[]{
                (byte) (value >> 24 & 0xFF), (byte) (value >> 16 & 0xFF),
                (byte) (value >> 8 & 0xFF), (byte) (value >> 0 & 0xFF)
        };
    }

    public static byte[] int64ToByteArray(long value) {
        return new byte[]{
                (byte) (value >> 56 & 0xFF), (byte) (value >> 48 & 0xFF),
                (byte) (value >> 40 & 0xFF), (byte) (value >> 32 & 0xFF),
                (byte) (value >> 24 & 0xFF), (byte) (value >> 16 & 0xFF),
                (byte) (value >> 8 & 0xFF), (byte) (value >> 0 & 0xFF)
        };
    }

    public static byte[] uInt64ToByteArray(BigInteger value) {
        byte[] buffer = value.toByteArray();
        return Arrays.copyOfRange(buffer, buffer.length - 8, buffer.length);
    }

    public static byte[] stringToByteArray(String value, int length) {
        byte[] bytes = new byte[length];
        for (int i = 0; i < value.length(); i++) {
            char charValue = value.charAt(i);
            bytes[i] = (byte) charValue;
        }
        return bytes;
    }

    public static byte[] booleanToByteArray(boolean value) {
        return value ? Utils.uInt8ToByteArray(1) : Utils.uInt8ToByteArray(0);
    }


    public static int uInt8FromByteArray(byte[] bytes, int offset) {
        return bytes[offset] & 0xFF;
    }

    public static int uInt16FromByteArray(byte[] bytes, int offset) {
        return ((bytes[offset] & 0xFF) << 8) + (bytes[offset + 1] & 0xFF);
    }

    public static long uInt32FromByteArray(byte[] bytes, int offset) {
        return ((long) (bytes[offset] & 0xFF) << 24)
                + ((bytes[offset + 1] & 0xFF) << 16)
                + ((bytes[offset + 2] & 0xFF) << 8)
                + (bytes[offset + 3] & 0xFF);
    }
    
    public static long int64FromByteArray(byte[] bytes, int offset) {
        return ((long) (bytes[offset] & 0xFF) << 56)
                + ((long) (bytes[offset + 1] & 0xFF) << 48)
                + ((long) (bytes[offset + 2] & 0xFF) << 32)
                + ((long) (bytes[offset + 3] & 0xFF) << 24)
                + ((bytes[offset + 4] & 0xFF) << 16)
                + ((bytes[offset + 5] & 0xFF) << 16)
                + ((bytes[offset + 6] & 0xFF) << 8)
                + (bytes[offset + 7] & 0xFF);
    }

    public static BigInteger uInt64FromByteArray(byte[] bytes, int offset) {
        return new BigInteger(1, Arrays.copyOfRange(bytes, offset, offset + 8));

    }

    public static String stringFromByteArray(byte[] bytes, int offset, int length) {
        int stringLength = length;
        char[] chars = new char[length];
        for (int i = 0; i < chars.length; i++) {
            chars[i] |=  ((int) bytes[offset + i]);
            if(((int) bytes[offset + i]) == 0) {
                stringLength = stringLength - 1;
            }
        }
        return new String(Arrays.copyOfRange(chars, 0, stringLength));
    }

    public static boolean booleanFromByteArray(byte[] bytes, int offset) {
        return bytes != null && bytes.length != 0 && bytes[offset] != 0x00;
    }
}

abstract class ByteSerializable {

    int byteLength;

    abstract void toBytes(ByteBuffer buffer);

    abstract byte[] toBytes();

}


class Bendec {
    void handleMessage(byte[] bytes) {
        MsgType msgType = MsgType.getMsgType(bytes, 4);
            switch (msgType) {

                case HEARTBEAT:
                    handleHeartbeat(bytes);
                    break;

                case TEXT:
                    handleText(bytes);
                    break;

                case TEST:
                    handleTest(bytes);
                    break;

                case TESTMAX:
                    handleTestMax(bytes);
                    break;

                case ORDERADD:
                    handleOrderAdd(bytes);
                    break;

                case ORDERMODIFY:
                    handleOrderModify(bytes);
                    break;

                case ORDERDELETE:
                    handleOrderDelete(bytes);
                    break;

                case ORDEREXECUTE:
                    handleOrderExecute(bytes);
                    break;

                case BUSINESSCLASSIFICATIONTREE:
                    handleBusinessClassificationTree(bytes);
                    break;

                case COUNTRY:
                    handleCountry(bytes);
                    break;

                case FINANCIALPRODUCTISSUER:
                    handleFinancialProductIssuer(bytes);
                    break;

                case MARKETOPERATOR:
                    handleMarketOperator(bytes);
                    break;

                case TRADINGVENUE:
                    handleTradingVenue(bytes);
                    break;

                case MARKETSEGMENTTYPE:
                    handleMarketSegmentType(bytes);
                    break;

                case TRADINGCONFIG:
                    handleTradingConfig(bytes);
                    break;

                case MARKETSEGMENT:
                    handleMarketSegment(bytes);
                    break;

                case FINANCIALPRODUCTCLASSIFICATIONTREE:
                    handleFinancialProductClassificationTree(bytes);
                    break;

                case TRADINGGROUP:
                    handleTradingGroup(bytes);
                    break;

                case FINANCIALPRODUCTSHARE:
                    handleFinancialProductShare(bytes);
                    break;

                case PRODUCTIDENTIFICATIONTYPE:
                    handleProductIdentificationType(bytes);
                    break;

                case CURRENCY:
                    handleCurrency(bytes);
                    break;

                case TRADABLEPRODUCT:
                    handleTradableProduct(bytes);
                    break;

                case BUSINESSCLASSIFICATIONMETHOD:
                    handleBusinessClassificationMethod(bytes);
                    break;

                case FINANCIALPRODUCTISSUERBUSINESSCLASSIFICATION:
                    handleFinancialProductIssuerBusinessClassification(bytes);
                    break;

                case FINANCIALPRODUCTBOND:
                    handleFinancialProductBond(bytes);
                    break;

                case FINANCIALPRODUCTCLASSIFICATIONMETHOD:
                    handleFinancialProductClassificationMethod(bytes);
                    break;

                case FINANCIALPRODUCTCLASSIFICATION:
                    handleFinancialProductClassification(bytes);
                    break;

                case TICKTABLEENTRY:
                    handleTickTableEntry(bytes);
                    break;

                case TICKTABLE:
                    handleTickTable(bytes);
                    break;

                case CALENDAR:
                    handleCalendar(bytes);
                    break;

                case CALENDAREXCEPTION:
                    handleCalendarException(bytes);
                    break;

                case PRICELEVELUPDATE:
                    handlePriceLevelUpdate(bytes);
                    break;

                case MARKETSEGMENTPRICELEVELCONFIG:
                    handleMarketSegmentPriceLevelConfig(bytes);
                    break;

                case COLLARTABLE:
                    handleCollarTable(bytes);
                    break;

                case ORDERCOLLARTABLEENTRY:
                    handleOrderCollarTableEntry(bytes);
                    break;

                case TRADECOLLARTABLEENTRY:
                    handleTradeCollarTableEntry(bytes);
                    break;

                case WEEKPLAN:
                    handleWeekPlan(bytes);
                    break;

                default:
                    System.out.println("unknown message type: " + msgType + bytes.toString());
                    break;
            }
    }



    void handleHeartbeat(byte[] bytes) {
        Heartbeat heartbeat = new Heartbeat(bytes, 0);
        System.out.println(heartbeat.toString());
    }

    void handleText(byte[] bytes) {
        Text text = new Text(bytes, 0);
        System.out.println(text.toString());
    }

    void handleTest(byte[] bytes) {
        Test test = new Test(bytes, 0);
        System.out.println(test.toString());
    }

    void handleTestMax(byte[] bytes) {
        TestMax testmax = new TestMax(bytes, 0);
        System.out.println(testmax.toString());
    }

    void handleOrderAdd(byte[] bytes) {
        OrderAdd orderadd = new OrderAdd(bytes, 0);
        System.out.println(orderadd.toString());
    }

    void handleOrderModify(byte[] bytes) {
        OrderModify ordermodify = new OrderModify(bytes, 0);
        System.out.println(ordermodify.toString());
    }

    void handleOrderDelete(byte[] bytes) {
        OrderDelete orderdelete = new OrderDelete(bytes, 0);
        System.out.println(orderdelete.toString());
    }

    void handleOrderExecute(byte[] bytes) {
        OrderExecute orderexecute = new OrderExecute(bytes, 0);
        System.out.println(orderexecute.toString());
    }

    void handleBusinessClassificationTree(byte[] bytes) {
        BusinessClassificationTree businessclassificationtree = new BusinessClassificationTree(bytes, 0);
        System.out.println(businessclassificationtree.toString());
    }

    void handleCountry(byte[] bytes) {
        Country country = new Country(bytes, 0);
        System.out.println(country.toString());
    }

    void handleFinancialProductIssuer(byte[] bytes) {
        FinancialProductIssuer financialproductissuer = new FinancialProductIssuer(bytes, 0);
        System.out.println(financialproductissuer.toString());
    }

    void handleMarketOperator(byte[] bytes) {
        MarketOperator marketoperator = new MarketOperator(bytes, 0);
        System.out.println(marketoperator.toString());
    }

    void handleTradingVenue(byte[] bytes) {
        TradingVenue tradingvenue = new TradingVenue(bytes, 0);
        System.out.println(tradingvenue.toString());
    }

    void handleMarketSegmentType(byte[] bytes) {
        MarketSegmentType marketsegmenttype = new MarketSegmentType(bytes, 0);
        System.out.println(marketsegmenttype.toString());
    }

    void handleTradingConfig(byte[] bytes) {
        TradingConfig tradingconfig = new TradingConfig(bytes, 0);
        System.out.println(tradingconfig.toString());
    }

    void handleMarketSegment(byte[] bytes) {
        MarketSegment marketsegment = new MarketSegment(bytes, 0);
        System.out.println(marketsegment.toString());
    }

    void handleFinancialProductClassificationTree(byte[] bytes) {
        FinancialProductClassificationTree financialproductclassificationtree = new FinancialProductClassificationTree(bytes, 0);
        System.out.println(financialproductclassificationtree.toString());
    }

    void handleTradingGroup(byte[] bytes) {
        TradingGroup tradinggroup = new TradingGroup(bytes, 0);
        System.out.println(tradinggroup.toString());
    }

    void handleFinancialProductShare(byte[] bytes) {
        FinancialProductShare financialproductshare = new FinancialProductShare(bytes, 0);
        System.out.println(financialproductshare.toString());
    }

    void handleProductIdentificationType(byte[] bytes) {
        ProductIdentificationType productidentificationtype = new ProductIdentificationType(bytes, 0);
        System.out.println(productidentificationtype.toString());
    }

    void handleCurrency(byte[] bytes) {
        Currency currency = new Currency(bytes, 0);
        System.out.println(currency.toString());
    }

    void handleTradableProduct(byte[] bytes) {
        TradableProduct tradableproduct = new TradableProduct(bytes, 0);
        System.out.println(tradableproduct.toString());
    }

    void handleBusinessClassificationMethod(byte[] bytes) {
        BusinessClassificationMethod businessclassificationmethod = new BusinessClassificationMethod(bytes, 0);
        System.out.println(businessclassificationmethod.toString());
    }

    void handleFinancialProductIssuerBusinessClassification(byte[] bytes) {
        FinancialProductIssuerBusinessClassification financialproductissuerbusinessclassification = new FinancialProductIssuerBusinessClassification(bytes, 0);
        System.out.println(financialproductissuerbusinessclassification.toString());
    }

    void handleFinancialProductBond(byte[] bytes) {
        FinancialProductBond financialproductbond = new FinancialProductBond(bytes, 0);
        System.out.println(financialproductbond.toString());
    }

    void handleFinancialProductClassificationMethod(byte[] bytes) {
        FinancialProductClassificationMethod financialproductclassificationmethod = new FinancialProductClassificationMethod(bytes, 0);
        System.out.println(financialproductclassificationmethod.toString());
    }

    void handleFinancialProductClassification(byte[] bytes) {
        FinancialProductClassification financialproductclassification = new FinancialProductClassification(bytes, 0);
        System.out.println(financialproductclassification.toString());
    }

    void handleTickTableEntry(byte[] bytes) {
        TickTableEntry ticktableentry = new TickTableEntry(bytes, 0);
        System.out.println(ticktableentry.toString());
    }

    void handleTickTable(byte[] bytes) {
        TickTable ticktable = new TickTable(bytes, 0);
        System.out.println(ticktable.toString());
    }

    void handleCalendar(byte[] bytes) {
        Calendar calendar = new Calendar(bytes, 0);
        System.out.println(calendar.toString());
    }

    void handleCalendarException(byte[] bytes) {
        CalendarException calendarexception = new CalendarException(bytes, 0);
        System.out.println(calendarexception.toString());
    }

    void handlePriceLevelUpdate(byte[] bytes) {
        PriceLevelUpdate pricelevelupdate = new PriceLevelUpdate(bytes, 0);
        System.out.println(pricelevelupdate.toString());
    }

    void handleMarketSegmentPriceLevelConfig(byte[] bytes) {
        MarketSegmentPriceLevelConfig marketsegmentpricelevelconfig = new MarketSegmentPriceLevelConfig(bytes, 0);
        System.out.println(marketsegmentpricelevelconfig.toString());
    }

    void handleCollarTable(byte[] bytes) {
        CollarTable collartable = new CollarTable(bytes, 0);
        System.out.println(collartable.toString());
    }

    void handleOrderCollarTableEntry(byte[] bytes) {
        OrderCollarTableEntry ordercollartableentry = new OrderCollarTableEntry(bytes, 0);
        System.out.println(ordercollartableentry.toString());
    }

    void handleTradeCollarTableEntry(byte[] bytes) {
        TradeCollarTableEntry tradecollartableentry = new TradeCollarTableEntry(bytes, 0);
        System.out.println(tradecollartableentry.toString());
    }

    void handleWeekPlan(byte[] bytes) {
        WeekPlan weekplan = new WeekPlan(bytes, 0);
        System.out.println(weekplan.toString());
    }

}



/**
 * <h2>Header</h2>
 * <p>Market Data message header.</p>
 * <p>Byte length: 26</p>
 * <p>MsgLength > int (u16) length - Message length. 2</p>
 *,<p>MsgVersion > int (u16) version - Indicates the version of the Market Data protocol in which the message is defined. 2</p>
 *,<p>MsgType msgType - Type of the message (e.g. OrderExecute). 2</p>
 *,<p>SeqNum > long (u32) seqNum - Sequence number of the message added by the Market Data Sequencer. 4</p>
 *,<p>Timestamp > BigInteger (u64) timestamp - Timestamp indicating when the message was sequenced. 8</p>
 *,<p>Timestamp > BigInteger (u64) sourceTimestamp - Timestamp added by the service which sent the message. 8</p>
 */
class Header extends ByteSerializable {

    private final int length;
    private final int version;
    private final MsgType msgType;
    private final long seqNum;
    private final BigInteger timestamp;
    private final BigInteger sourceTimestamp;
    private final int byteLength = 26;

    Header(int length, int version, MsgType msgType, long seqNum, BigInteger timestamp, BigInteger sourceTimestamp) {
        this.length = length;
        this.version = version;
        this.msgType = msgType;
        this.seqNum = seqNum;
        this.timestamp = timestamp;
        this.sourceTimestamp = sourceTimestamp;
    }

    Header(byte[] bytes, int offset) {
        this.length = Utils.uInt16FromByteArray(bytes, offset);
        this.version = Utils.uInt16FromByteArray(bytes, offset + 2);
        this.msgType = MsgType.getMsgType(bytes, offset + 4);
        this.seqNum = Utils.uInt32FromByteArray(bytes, offset + 6);
        this.timestamp = Utils.uInt64FromByteArray(bytes, offset + 10);
        this.sourceTimestamp = Utils.uInt64FromByteArray(bytes, offset + 18);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.length);
        buffer.putInt(this.version);
        msgType.toBytes(buffer);
        buffer.putLong(this.seqNum);
        buffer.put(Utils.uInt64ToByteArray(this.timestamp));
        buffer.put(Utils.uInt64ToByteArray(this.sourceTimestamp));
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.length);
        buffer.putInt(this.version);
        msgType.toBytes(buffer);
        buffer.putLong(this.seqNum);
        buffer.put(Utils.uInt64ToByteArray(this.timestamp));
        buffer.put(Utils.uInt64ToByteArray(this.sourceTimestamp));
    }

}




/**
 * <h2>ReplayRequest</h2>
 * <p>Message replay request.</p>
 * <p>Byte length: 8</p>
 * <p>SeqNum > long (u32) seqNum - Initial sequence number for the requested range. 4</p>
 *,<p>SeqNum > long (u32) endSeqNum - Final sequence number for the requested range. 4</p>
 */
class ReplayRequest extends ByteSerializable {

    private final long seqNum;
    private final long endSeqNum;
    private final int byteLength = 8;

    ReplayRequest(long seqNum, long endSeqNum) {
        this.seqNum = seqNum;
        this.endSeqNum = endSeqNum;
    }

    ReplayRequest(byte[] bytes, int offset) {
        this.seqNum = Utils.uInt32FromByteArray(bytes, offset);
        this.endSeqNum = Utils.uInt32FromByteArray(bytes, offset + 4);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putLong(this.seqNum);
        buffer.putLong(this.endSeqNum);
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        buffer.putLong(this.seqNum);
        buffer.putLong(this.endSeqNum);
    }

}




/**
 * <h2>BusinessClassificationMethod</h2>
 * <p>Defines a business classification method.</p>
 * <p>Byte length: 80</p>
 * <p>Header header - Message header. 26</p>
 *,<p>BusinessClassificationMethodId > long (u32) businessClassificationMethodId - Business classification method ID. 4</p>
 *,<p>BusinessClassificationMethodName > String (char[]) businessClassificationMethodName - Business classification method name. 50</p>
 */
class BusinessClassificationMethod extends ByteSerializable {

    private final Header header;
    private final long businessClassificationMethodId;
    private final String businessClassificationMethodName;
    private final int byteLength = 80;

    BusinessClassificationMethod(Header header, long businessClassificationMethodId, String businessClassificationMethodName) {
        this.header = header;
        this.businessClassificationMethodId = businessClassificationMethodId;
        this.businessClassificationMethodName = businessClassificationMethodName;
    }

    BusinessClassificationMethod(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.businessClassificationMethodId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.businessClassificationMethodName = Utils.stringFromByteArray(bytes, offset + 30, 50);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.businessClassificationMethodId);
        buffer.put(Utils.stringToByteArray(this.businessClassificationMethodName, 50));
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.businessClassificationMethodId);
        buffer.put(Utils.stringToByteArray(this.businessClassificationMethodName, 50));
    }

}




/**
 * <h2>BusinessClassificationTree</h2>
 * <p>List of defined business classifications.</p>
 * <p>Byte length: 98</p>
 * <p>Header header - Message header. 26</p>
 *,<p>BusinessClassificationTreeId > long (u32) businessClassificationTreeId - ID of the business classification. 4</p>
 *,<p>BusinessClassificationTreeId > long (u32) businessClassificationTreeParentId - ID of the parent business classification (if the given classification is a sub-classification).
When there's no parent business classification, the value is set to 0. 4</p>
 *,<p>BusinessClassificationTreeName > String (char[]) businessClassificationTreeName - Name of the business classification. 50</p>
 *,<p>BusinessClassificationTreeCode > String (char[]) businessClassificationTreeCode - Code of the business classification. 10</p>
 *,<p>BusinessClassificationMethodId > long (u32) businessClassificationMethodId - Business classification method ID. 4</p>
 */
class BusinessClassificationTree extends ByteSerializable {

    private final Header header;
    private final long businessClassificationTreeId;
    private final long businessClassificationTreeParentId;
    private final String businessClassificationTreeName;
    private final String businessClassificationTreeCode;
    private final long businessClassificationMethodId;
    private final int byteLength = 98;

    BusinessClassificationTree(Header header, long businessClassificationTreeId, long businessClassificationTreeParentId, String businessClassificationTreeName, String businessClassificationTreeCode, long businessClassificationMethodId) {
        this.header = header;
        this.businessClassificationTreeId = businessClassificationTreeId;
        this.businessClassificationTreeParentId = businessClassificationTreeParentId;
        this.businessClassificationTreeName = businessClassificationTreeName;
        this.businessClassificationTreeCode = businessClassificationTreeCode;
        this.businessClassificationMethodId = businessClassificationMethodId;
    }

    BusinessClassificationTree(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.businessClassificationTreeId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.businessClassificationTreeParentId = Utils.uInt32FromByteArray(bytes, offset + 30);
        this.businessClassificationTreeName = Utils.stringFromByteArray(bytes, offset + 34, 50);
        this.businessClassificationTreeCode = Utils.stringFromByteArray(bytes, offset + 84, 10);
        this.businessClassificationMethodId = Utils.uInt32FromByteArray(bytes, offset + 94);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.businessClassificationTreeId);
        buffer.putLong(this.businessClassificationTreeParentId);
        buffer.put(Utils.stringToByteArray(this.businessClassificationTreeName, 50));
        buffer.put(Utils.stringToByteArray(this.businessClassificationTreeCode, 10));
        buffer.putLong(this.businessClassificationMethodId);
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.businessClassificationTreeId);
        buffer.putLong(this.businessClassificationTreeParentId);
        buffer.put(Utils.stringToByteArray(this.businessClassificationTreeName, 50));
        buffer.put(Utils.stringToByteArray(this.businessClassificationTreeCode, 10));
        buffer.putLong(this.businessClassificationMethodId);
    }

}




/**
 * <h2>Calendar</h2>
 * <p>Message containing a trading calendar.</p>
 * <p>Byte length: 80</p>
 * <p>Header header - Message header. 26</p>
 *,<p>CalendarId > long (u32) calendarId - ID of the trading calendar. 4</p>
 *,<p>CalendarName > String (char[]) calendarName - Name of the trading calendar. 50</p>
 */
class Calendar extends ByteSerializable {

    private final Header header;
    private final long calendarId;
    private final String calendarName;
    private final int byteLength = 80;

    Calendar(Header header, long calendarId, String calendarName) {
        this.header = header;
        this.calendarId = calendarId;
        this.calendarName = calendarName;
    }

    Calendar(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.calendarId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.calendarName = Utils.stringFromByteArray(bytes, offset + 30, 50);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.calendarId);
        buffer.put(Utils.stringToByteArray(this.calendarName, 50));
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.calendarId);
        buffer.put(Utils.stringToByteArray(this.calendarName, 50));
    }

}




/**
 * <h2>CalendarException</h2>
 * <p>Message containing a calendar exception.</p>
 * <p>Byte length: 90</p>
 * <p>Header header - Message header. 26</p>
 *,<p>CalendarExceptionId > long (u32) calendarExceptionId - Calendar exception ID. 4</p>
 *,<p>Date > long (u32) calendarExceptionDate - Calendar exception date. 4</p>
 *,<p>CalendarExceptionComment > String (char[]) calendarExceptionComment - Calendar exception comment. 50</p>
 *,<p>CalendarExceptionRecurrent > boolean (bool) calendarExceptionRecurrent - Indicates whether a calendar exception is recurring or not. 1</p>
 *,<p>CalendarExceptionType calendarExceptionType - Calendar exception type ID. 1</p>
 *,<p>CalendarId > long (u32) calendarId - Calendar ID. 4</p>
 */
class CalendarException extends ByteSerializable {

    private final Header header;
    private final long calendarExceptionId;
    private final long calendarExceptionDate;
    private final String calendarExceptionComment;
    private final boolean calendarExceptionRecurrent;
    private final CalendarExceptionType calendarExceptionType;
    private final long calendarId;
    private final int byteLength = 90;

    CalendarException(Header header, long calendarExceptionId, long calendarExceptionDate, String calendarExceptionComment, boolean calendarExceptionRecurrent, CalendarExceptionType calendarExceptionType, long calendarId) {
        this.header = header;
        this.calendarExceptionId = calendarExceptionId;
        this.calendarExceptionDate = calendarExceptionDate;
        this.calendarExceptionComment = calendarExceptionComment;
        this.calendarExceptionRecurrent = calendarExceptionRecurrent;
        this.calendarExceptionType = calendarExceptionType;
        this.calendarId = calendarId;
    }

    CalendarException(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.calendarExceptionId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.calendarExceptionDate = Utils.uInt32FromByteArray(bytes, offset + 30);
        this.calendarExceptionComment = Utils.stringFromByteArray(bytes, offset + 34, 50);
        this.calendarExceptionRecurrent = Utils.booleanFromByteArray(bytes, offset + 84);
        this.calendarExceptionType = CalendarExceptionType.getCalendarExceptionType(bytes, offset + 85);
        this.calendarId = Utils.uInt32FromByteArray(bytes, offset + 86);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.calendarExceptionId);
        buffer.putLong(this.calendarExceptionDate);
        buffer.put(Utils.stringToByteArray(this.calendarExceptionComment, 50));
        buffer.put(Utils.booleanToByteArray(this.calendarExceptionRecurrent));
        calendarExceptionType.toBytes(buffer);
        buffer.putLong(this.calendarId);
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.calendarExceptionId);
        buffer.putLong(this.calendarExceptionDate);
        buffer.put(Utils.stringToByteArray(this.calendarExceptionComment, 50));
        buffer.put(Utils.booleanToByteArray(this.calendarExceptionRecurrent));
        calendarExceptionType.toBytes(buffer);
        buffer.putLong(this.calendarId);
    }

}




/**
 * <h2>CollarTable</h2>
 * <p>Message describing a collar table.</p>
 * <p>Byte length: 81</p>
 * <p>Header header - Message header. 26</p>
 *,<p>CollarTableId > long (u32) collarTableId - Collar table ID. 4</p>
 *,<p>CollarTableName > String (char[]) collarTableName - Collar table name. 50</p>
 *,<p>CollarMode collarModeId - Collar mode (trade price collar or order price collar). 1</p>
 */
class CollarTable extends ByteSerializable {

    private final Header header;
    private final long collarTableId;
    private final String collarTableName;
    private final CollarMode collarModeId;
    private final int byteLength = 81;

    CollarTable(Header header, long collarTableId, String collarTableName, CollarMode collarModeId) {
        this.header = header;
        this.collarTableId = collarTableId;
        this.collarTableName = collarTableName;
        this.collarModeId = collarModeId;
    }

    CollarTable(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.collarTableId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.collarTableName = Utils.stringFromByteArray(bytes, offset + 30, 50);
        this.collarModeId = CollarMode.getCollarMode(bytes, offset + 80);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.collarTableId);
        buffer.put(Utils.stringToByteArray(this.collarTableName, 50));
        collarModeId.toBytes(buffer);
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.collarTableId);
        buffer.put(Utils.stringToByteArray(this.collarTableName, 50));
        collarModeId.toBytes(buffer);
    }

}




/**
 * <h2>Country</h2>
 * <p>List of defined countries.</p>
 * <p>Byte length: 81</p>
 * <p>Header header - Message header. 26</p>
 *,<p>CountryId > String (char[]) countryId - Two-letter country code. 2</p>
 *,<p>CountryCode > String (char[]) countryCode - Three-letter country code. 3</p>
 *,<p>CountryName > String (char[]) countryName - Country name, for example "Poland". 50</p>
 */
class Country extends ByteSerializable {

    private final Header header;
    private final String countryId;
    private final String countryCode;
    private final String countryName;
    private final int byteLength = 81;

    Country(Header header, String countryId, String countryCode, String countryName) {
        this.header = header;
        this.countryId = countryId;
        this.countryCode = countryCode;
        this.countryName = countryName;
    }

    Country(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.countryId = Utils.stringFromByteArray(bytes, offset + 26, 2);
        this.countryCode = Utils.stringFromByteArray(bytes, offset + 28, 3);
        this.countryName = Utils.stringFromByteArray(bytes, offset + 31, 50);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.put(Utils.stringToByteArray(this.countryId, 2));
        buffer.put(Utils.stringToByteArray(this.countryCode, 3));
        buffer.put(Utils.stringToByteArray(this.countryName, 50));
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.put(Utils.stringToByteArray(this.countryId, 2));
        buffer.put(Utils.stringToByteArray(this.countryCode, 3));
        buffer.put(Utils.stringToByteArray(this.countryName, 50));
    }

}




/**
 * <h2>Currency</h2>
 * <p>List of defined currencies.</p>
 * <p>Byte length: 80</p>
 * <p>Header header - Message header. 26</p>
 *,<p>CurrencyId > String (char[]) currencyId - Three-letter ID of a given currency (e.g. USD). 3</p>
 *,<p>CurrencyName > String (char[]) currencyName - Name of the currency, for example "Pound sterling". 50</p>
 *,<p>Precision > int (u8) currencyPrecision - undefined 1</p>
 */
class Currency extends ByteSerializable {

    private final Header header;
    private final String currencyId;
    private final String currencyName;
    private final int currencyPrecision;
    private final int byteLength = 80;

    Currency(Header header, String currencyId, String currencyName, int currencyPrecision) {
        this.header = header;
        this.currencyId = currencyId;
        this.currencyName = currencyName;
        this.currencyPrecision = currencyPrecision;
    }

    Currency(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.currencyId = Utils.stringFromByteArray(bytes, offset + 26, 3);
        this.currencyName = Utils.stringFromByteArray(bytes, offset + 29, 50);
        this.currencyPrecision = Utils.uInt8FromByteArray(bytes, offset + 79);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.put(Utils.stringToByteArray(this.currencyId, 3));
        buffer.put(Utils.stringToByteArray(this.currencyName, 50));
        buffer.putInt(this.currencyPrecision);
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.put(Utils.stringToByteArray(this.currencyId, 3));
        buffer.put(Utils.stringToByteArray(this.currencyName, 50));
        buffer.putInt(this.currencyPrecision);
    }

}




/**
 * <h2>FinancialProductBond</h2>
 * <p>List of defined products.</p>
 * <p>Byte length: 216</p>
 * <p>Header header - Message header. 26</p>
 *,<p>ProductId > long (u32) productId - ID of the product. 4</p>
 *,<p>ProductIdentification > String (char[]) productIdentification - Product identification, for example its ISIN number. 50</p>
 *,<p>ProductName > String (char[]) productName - Name of the product. 50</p>
 *,<p>ProductIdentificationTypeId > long (u32) productIdentificationTypeId - ID of the product identification type (for example ISIN or SEDOL). 4</p>
 *,<p>ProductUnderlyingId > long (u32) productUnderlyingId - ID of underlying.
 4</p>
 *,<p>FinancialProductIssuerId > long (u32) financialProductIssuerId - ID of the product's issuer. 4</p>
 *,<p>CfiCode > String (char[]) financialProductCfi - Product's CFI code as specified in ISO 18774. 6</p>
 *,<p>FisnCode > String (char[]) financialProductFisn - Product's FISN code as specified in ISO 10962. 35</p>
 *,<p>NominalValueType nominalValueType - Type of the product's nominal value (no nominal, constant or unknown). 1</p>
 *,<p>ProductNominalValue > long (i64) financialProductNominalValue - Nominal value of the product. 8</p>
 *,<p>IssueSizeType issueSizeType - ID of the product's issue size type (quantity, value or no issue size). 1</p>
 *,<p>ProductIssueSize > BigInteger (u64) financialProductIssueSize - Issue size of the product. 8</p>
 *,<p>CurrencyId > String (char[]) nominalCurrencyId - Currency in which the product is denominated (three-letter code). 3</p>
 *,<p>MifirIdentifier mifirIdentifier - undefined 1</p>
 *,<p>LiquidityFlag liquidityFlag - undefined 1</p>
 *,<p>Date > long (u32) financialProductBondExpiryDate - Date on which the bond expires. 4</p>
 *,<p>FinancialProductBondCouponFrequency > long (u32) financialProductBondCouponFrequency - undefined 4</p>
 *,<p>SeniorityBond seniorityBond - The bond's seniority. 1</p>
 *,<p>CouponType couponType - undefined 1</p>
 */
class FinancialProductBond extends ByteSerializable {

    private final Header header;
    private final long productId;
    private final String productIdentification;
    private final String productName;
    private final long productIdentificationTypeId;
    private final long productUnderlyingId;
    private final long financialProductIssuerId;
    private final String financialProductCfi;
    private final String financialProductFisn;
    private final NominalValueType nominalValueType;
    private final long financialProductNominalValue;
    private final IssueSizeType issueSizeType;
    private final BigInteger financialProductIssueSize;
    private final String nominalCurrencyId;
    private final MifirIdentifier mifirIdentifier;
    private final LiquidityFlag liquidityFlag;
    private final long financialProductBondExpiryDate;
    private final long financialProductBondCouponFrequency;
    private final SeniorityBond seniorityBond;
    private final CouponType couponType;
    private final int byteLength = 216;

    FinancialProductBond(Header header, long productId, String productIdentification, String productName, long productIdentificationTypeId, long productUnderlyingId, long financialProductIssuerId, String financialProductCfi, String financialProductFisn, NominalValueType nominalValueType, long financialProductNominalValue, IssueSizeType issueSizeType, BigInteger financialProductIssueSize, String nominalCurrencyId, MifirIdentifier mifirIdentifier, LiquidityFlag liquidityFlag, long financialProductBondExpiryDate, long financialProductBondCouponFrequency, SeniorityBond seniorityBond, CouponType couponType) {
        this.header = header;
        this.productId = productId;
        this.productIdentification = productIdentification;
        this.productName = productName;
        this.productIdentificationTypeId = productIdentificationTypeId;
        this.productUnderlyingId = productUnderlyingId;
        this.financialProductIssuerId = financialProductIssuerId;
        this.financialProductCfi = financialProductCfi;
        this.financialProductFisn = financialProductFisn;
        this.nominalValueType = nominalValueType;
        this.financialProductNominalValue = financialProductNominalValue;
        this.issueSizeType = issueSizeType;
        this.financialProductIssueSize = financialProductIssueSize;
        this.nominalCurrencyId = nominalCurrencyId;
        this.mifirIdentifier = mifirIdentifier;
        this.liquidityFlag = liquidityFlag;
        this.financialProductBondExpiryDate = financialProductBondExpiryDate;
        this.financialProductBondCouponFrequency = financialProductBondCouponFrequency;
        this.seniorityBond = seniorityBond;
        this.couponType = couponType;
    }

    FinancialProductBond(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.productId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.productIdentification = Utils.stringFromByteArray(bytes, offset + 30, 50);
        this.productName = Utils.stringFromByteArray(bytes, offset + 80, 50);
        this.productIdentificationTypeId = Utils.uInt32FromByteArray(bytes, offset + 130);
        this.productUnderlyingId = Utils.uInt32FromByteArray(bytes, offset + 134);
        this.financialProductIssuerId = Utils.uInt32FromByteArray(bytes, offset + 138);
        this.financialProductCfi = Utils.stringFromByteArray(bytes, offset + 142, 6);
        this.financialProductFisn = Utils.stringFromByteArray(bytes, offset + 148, 35);
        this.nominalValueType = NominalValueType.getNominalValueType(bytes, offset + 183);
        this.financialProductNominalValue = Utils.int64FromByteArray(bytes, offset + 184);
        this.issueSizeType = IssueSizeType.getIssueSizeType(bytes, offset + 192);
        this.financialProductIssueSize = Utils.uInt64FromByteArray(bytes, offset + 193);
        this.nominalCurrencyId = Utils.stringFromByteArray(bytes, offset + 201, 3);
        this.mifirIdentifier = MifirIdentifier.getMifirIdentifier(bytes, offset + 204);
        this.liquidityFlag = LiquidityFlag.getLiquidityFlag(bytes, offset + 205);
        this.financialProductBondExpiryDate = Utils.uInt32FromByteArray(bytes, offset + 206);
        this.financialProductBondCouponFrequency = Utils.uInt32FromByteArray(bytes, offset + 210);
        this.seniorityBond = SeniorityBond.getSeniorityBond(bytes, offset + 214);
        this.couponType = CouponType.getCouponType(bytes, offset + 215);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.productId);
        buffer.put(Utils.stringToByteArray(this.productIdentification, 50));
        buffer.put(Utils.stringToByteArray(this.productName, 50));
        buffer.putLong(this.productIdentificationTypeId);
        buffer.putLong(this.productUnderlyingId);
        buffer.putLong(this.financialProductIssuerId);
        buffer.put(Utils.stringToByteArray(this.financialProductCfi, 6));
        buffer.put(Utils.stringToByteArray(this.financialProductFisn, 35));
        nominalValueType.toBytes(buffer);
        buffer.put(Utils.int64ToByteArray(this.financialProductNominalValue));
        issueSizeType.toBytes(buffer);
        buffer.put(Utils.uInt64ToByteArray(this.financialProductIssueSize));
        buffer.put(Utils.stringToByteArray(this.nominalCurrencyId, 3));
        mifirIdentifier.toBytes(buffer);
        liquidityFlag.toBytes(buffer);
        buffer.putLong(this.financialProductBondExpiryDate);
        buffer.putLong(this.financialProductBondCouponFrequency);
        seniorityBond.toBytes(buffer);
        couponType.toBytes(buffer);
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.productId);
        buffer.put(Utils.stringToByteArray(this.productIdentification, 50));
        buffer.put(Utils.stringToByteArray(this.productName, 50));
        buffer.putLong(this.productIdentificationTypeId);
        buffer.putLong(this.productUnderlyingId);
        buffer.putLong(this.financialProductIssuerId);
        buffer.put(Utils.stringToByteArray(this.financialProductCfi, 6));
        buffer.put(Utils.stringToByteArray(this.financialProductFisn, 35));
        nominalValueType.toBytes(buffer);
        buffer.put(Utils.int64ToByteArray(this.financialProductNominalValue));
        issueSizeType.toBytes(buffer);
        buffer.put(Utils.uInt64ToByteArray(this.financialProductIssueSize));
        buffer.put(Utils.stringToByteArray(this.nominalCurrencyId, 3));
        mifirIdentifier.toBytes(buffer);
        liquidityFlag.toBytes(buffer);
        buffer.putLong(this.financialProductBondExpiryDate);
        buffer.putLong(this.financialProductBondCouponFrequency);
        seniorityBond.toBytes(buffer);
        couponType.toBytes(buffer);
    }

}




/**
 * <h2>FinancialProductClassification</h2>
 * <p>Message defining a financial product classification.</p>
 * <p>Byte length: 38</p>
 * <p>Header header - Message header. 26</p>
 *,<p>FinancialProductClassificationId > long (u32) financialProductClassificationId - ID of the financial product classification. 4</p>
 *,<p>FinancialProductClassificationTreeId > long (u32) financialProductClassificationTreeId - ID of the financial product classification tree. 4</p>
 *,<p>ProductId > long (u32) productId - ID of the product. 4</p>
 */
class FinancialProductClassification extends ByteSerializable {

    private final Header header;
    private final long financialProductClassificationId;
    private final long financialProductClassificationTreeId;
    private final long productId;
    private final int byteLength = 38;

    FinancialProductClassification(Header header, long financialProductClassificationId, long financialProductClassificationTreeId, long productId) {
        this.header = header;
        this.financialProductClassificationId = financialProductClassificationId;
        this.financialProductClassificationTreeId = financialProductClassificationTreeId;
        this.productId = productId;
    }

    FinancialProductClassification(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.financialProductClassificationId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.financialProductClassificationTreeId = Utils.uInt32FromByteArray(bytes, offset + 30);
        this.productId = Utils.uInt32FromByteArray(bytes, offset + 34);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.financialProductClassificationId);
        buffer.putLong(this.financialProductClassificationTreeId);
        buffer.putLong(this.productId);
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.financialProductClassificationId);
        buffer.putLong(this.financialProductClassificationTreeId);
        buffer.putLong(this.productId);
    }

}




/**
 * <h2>FinancialProductClassificationMethod</h2>
 * <p>Message defining a financial product classification method.</p>
 * <p>Byte length: 80</p>
 * <p>Header header - Message header. 26</p>
 *,<p>FinancialProductClassificationMethodId > long (u32) financialProductClassificationMethodId - ID of the financial product classification method. 4</p>
 *,<p>FinancialProductClassificationMethodName > String (char[]) financialProductClassificationMethodName - Name of the financial product classification method. 50</p>
 */
class FinancialProductClassificationMethod extends ByteSerializable {

    private final Header header;
    private final long financialProductClassificationMethodId;
    private final String financialProductClassificationMethodName;
    private final int byteLength = 80;

    FinancialProductClassificationMethod(Header header, long financialProductClassificationMethodId, String financialProductClassificationMethodName) {
        this.header = header;
        this.financialProductClassificationMethodId = financialProductClassificationMethodId;
        this.financialProductClassificationMethodName = financialProductClassificationMethodName;
    }

    FinancialProductClassificationMethod(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.financialProductClassificationMethodId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.financialProductClassificationMethodName = Utils.stringFromByteArray(bytes, offset + 30, 50);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.financialProductClassificationMethodId);
        buffer.put(Utils.stringToByteArray(this.financialProductClassificationMethodName, 50));
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.financialProductClassificationMethodId);
        buffer.put(Utils.stringToByteArray(this.financialProductClassificationMethodName, 50));
    }

}




/**
 * <h2>FinancialProductClassificationTree</h2>
 * <p>List of defined product types.</p>
 * <p>Byte length: 98</p>
 * <p>Header header - Message header. 26</p>
 *,<p>FinancialProductClassificationTreeId > long (u32) financialProductClassificationTreeId - ID of the product type. 4</p>
 *,<p>FinancialProductClassificationTreeName > String (char[]) financialProductClassificationTreeName - Name of the product type. 50</p>
 *,<p>FinancialProductClassificationTreeId > long (u32) financialProductClassificationTreeParentId - ID of the parent product. 4</p>
 *,<p>FinancialProductClassificationTreeCode > String (char[]) financialProductClassificationTreeCode - ID of the parent product type (if the current type is a sub-type).
When there's no parent product type, the value is set to 0. 10</p>
 *,<p>FinancialProductClassificationMethodId > long (u32) financialProductClassificationMethodId - Code of the product type. 4</p>
 */
class FinancialProductClassificationTree extends ByteSerializable {

    private final Header header;
    private final long financialProductClassificationTreeId;
    private final String financialProductClassificationTreeName;
    private final long financialProductClassificationTreeParentId;
    private final String financialProductClassificationTreeCode;
    private final long financialProductClassificationMethodId;
    private final int byteLength = 98;

    FinancialProductClassificationTree(Header header, long financialProductClassificationTreeId, String financialProductClassificationTreeName, long financialProductClassificationTreeParentId, String financialProductClassificationTreeCode, long financialProductClassificationMethodId) {
        this.header = header;
        this.financialProductClassificationTreeId = financialProductClassificationTreeId;
        this.financialProductClassificationTreeName = financialProductClassificationTreeName;
        this.financialProductClassificationTreeParentId = financialProductClassificationTreeParentId;
        this.financialProductClassificationTreeCode = financialProductClassificationTreeCode;
        this.financialProductClassificationMethodId = financialProductClassificationMethodId;
    }

    FinancialProductClassificationTree(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.financialProductClassificationTreeId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.financialProductClassificationTreeName = Utils.stringFromByteArray(bytes, offset + 30, 50);
        this.financialProductClassificationTreeParentId = Utils.uInt32FromByteArray(bytes, offset + 80);
        this.financialProductClassificationTreeCode = Utils.stringFromByteArray(bytes, offset + 84, 10);
        this.financialProductClassificationMethodId = Utils.uInt32FromByteArray(bytes, offset + 94);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.financialProductClassificationTreeId);
        buffer.put(Utils.stringToByteArray(this.financialProductClassificationTreeName, 50));
        buffer.putLong(this.financialProductClassificationTreeParentId);
        buffer.put(Utils.stringToByteArray(this.financialProductClassificationTreeCode, 10));
        buffer.putLong(this.financialProductClassificationMethodId);
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.financialProductClassificationTreeId);
        buffer.put(Utils.stringToByteArray(this.financialProductClassificationTreeName, 50));
        buffer.putLong(this.financialProductClassificationTreeParentId);
        buffer.put(Utils.stringToByteArray(this.financialProductClassificationTreeCode, 10));
        buffer.putLong(this.financialProductClassificationMethodId);
    }

}




/**
 * <h2>FinancialProductIssuer</h2>
 * <p>Collection of defined issuers of financial products.</p>
 * <p>Byte length: 212</p>
 * <p>Header header - Message header. 26</p>
 *,<p>FinancialProductIssuerId > long (u32) financialProductIssuerId - Identifier of an issuer. 4</p>
 *,<p>FinancialProductIssuerName > String (char[]) financialProductIssuerName - Name of an issuer. 150</p>
 *,<p>LeiCode > String (char[]) financialProductIssuerLei - Issuer's Legal Entity Identifier as specified in ISO 17422. 20</p>
 *,<p>BicCode > String (char[]) financialProductIssuerBic - Issuer's Business Identification Code as specified in ISO 9362. 8</p>
 *,<p>CountryId > String (char[]) registrationCountryId - Country of the registration (two-letter country code) of the issuer. 2</p>
 *,<p>CountryId > String (char[]) mainActivityCountryId - Country of the main activity (two-letter country code) of the issuer. 2</p>
 */
class FinancialProductIssuer extends ByteSerializable {

    private final Header header;
    private final long financialProductIssuerId;
    private final String financialProductIssuerName;
    private final String financialProductIssuerLei;
    private final String financialProductIssuerBic;
    private final String registrationCountryId;
    private final String mainActivityCountryId;
    private final int byteLength = 212;

    FinancialProductIssuer(Header header, long financialProductIssuerId, String financialProductIssuerName, String financialProductIssuerLei, String financialProductIssuerBic, String registrationCountryId, String mainActivityCountryId) {
        this.header = header;
        this.financialProductIssuerId = financialProductIssuerId;
        this.financialProductIssuerName = financialProductIssuerName;
        this.financialProductIssuerLei = financialProductIssuerLei;
        this.financialProductIssuerBic = financialProductIssuerBic;
        this.registrationCountryId = registrationCountryId;
        this.mainActivityCountryId = mainActivityCountryId;
    }

    FinancialProductIssuer(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.financialProductIssuerId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.financialProductIssuerName = Utils.stringFromByteArray(bytes, offset + 30, 150);
        this.financialProductIssuerLei = Utils.stringFromByteArray(bytes, offset + 180, 20);
        this.financialProductIssuerBic = Utils.stringFromByteArray(bytes, offset + 200, 8);
        this.registrationCountryId = Utils.stringFromByteArray(bytes, offset + 208, 2);
        this.mainActivityCountryId = Utils.stringFromByteArray(bytes, offset + 210, 2);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.financialProductIssuerId);
        buffer.put(Utils.stringToByteArray(this.financialProductIssuerName, 150));
        buffer.put(Utils.stringToByteArray(this.financialProductIssuerLei, 20));
        buffer.put(Utils.stringToByteArray(this.financialProductIssuerBic, 8));
        buffer.put(Utils.stringToByteArray(this.registrationCountryId, 2));
        buffer.put(Utils.stringToByteArray(this.mainActivityCountryId, 2));
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.financialProductIssuerId);
        buffer.put(Utils.stringToByteArray(this.financialProductIssuerName, 150));
        buffer.put(Utils.stringToByteArray(this.financialProductIssuerLei, 20));
        buffer.put(Utils.stringToByteArray(this.financialProductIssuerBic, 8));
        buffer.put(Utils.stringToByteArray(this.registrationCountryId, 2));
        buffer.put(Utils.stringToByteArray(this.mainActivityCountryId, 2));
    }

}




/**
 * <h2>FinancialProductIssuerBusinessClassification</h2>
 * <p>Business classification for issuer.
</p>
 * <p>Byte length: 38</p>
 * <p>Header header - Message header. 26</p>
 *,<p>FinancialProductIssuerBusinessClassificationId > long (u32) financialProductIssuerBusinessClassificationId - Unique key for classification of the issuer. 4</p>
 *,<p>BusinessClassificationTreeId > long (u32) businessClassificationTreeId - Business classification key. 4</p>
 *,<p>FinancialProductIssuerId > long (u32) financialProductIssuerId - Issuer key. 4</p>
 */
class FinancialProductIssuerBusinessClassification extends ByteSerializable {

    private final Header header;
    private final long financialProductIssuerBusinessClassificationId;
    private final long businessClassificationTreeId;
    private final long financialProductIssuerId;
    private final int byteLength = 38;

    FinancialProductIssuerBusinessClassification(Header header, long financialProductIssuerBusinessClassificationId, long businessClassificationTreeId, long financialProductIssuerId) {
        this.header = header;
        this.financialProductIssuerBusinessClassificationId = financialProductIssuerBusinessClassificationId;
        this.businessClassificationTreeId = businessClassificationTreeId;
        this.financialProductIssuerId = financialProductIssuerId;
    }

    FinancialProductIssuerBusinessClassification(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.financialProductIssuerBusinessClassificationId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.businessClassificationTreeId = Utils.uInt32FromByteArray(bytes, offset + 30);
        this.financialProductIssuerId = Utils.uInt32FromByteArray(bytes, offset + 34);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.financialProductIssuerBusinessClassificationId);
        buffer.putLong(this.businessClassificationTreeId);
        buffer.putLong(this.financialProductIssuerId);
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.financialProductIssuerBusinessClassificationId);
        buffer.putLong(this.businessClassificationTreeId);
        buffer.putLong(this.financialProductIssuerId);
    }

}




/**
 * <h2>FinancialProductShare</h2>
 * <p>List of defined products.</p>
 * <p>Byte length: 205</p>
 * <p>Header header - Message header. 26</p>
 *,<p>ProductId > long (u32) productId - ID of the product. 4</p>
 *,<p>ProductIdentification > String (char[]) productIdentification - Product identification, for example its ISIN number. 50</p>
 *,<p>ProductName > String (char[]) productName - Name of the product. 50</p>
 *,<p>ProductIdentificationTypeId > long (u32) productIdentificationTypeId - ID of the product identification type (for example ISIN or SEDOL). 4</p>
 *,<p>ProductId > long (u32) productUnderlyingId - ID of the underlying product. 4</p>
 *,<p>FinancialProductIssuerId > long (u32) financialProductIssuerId - ID of the product's issuer. 4</p>
 *,<p>CfiCode > String (char[]) financialProductCfi - Product's CFI code as specified in ISO 18774. 6</p>
 *,<p>FisnCode > String (char[]) financialProductFisn - Product's FISN code as specified in ISO 10962. 35</p>
 *,<p>NominalValueType nominalValueType - Type of the product's nominal value (no nominal, constant or unknown). 1</p>
 *,<p>ProductNominalValue > long (i64) financialProductNominalValue - Nominal value of the product. 8</p>
 *,<p>IssueSizeType issueSizeType - ID of the product's issue size type (quantity, value or no issue size). 1</p>
 *,<p>ProductIssueSize > BigInteger (u64) financialProductIssueSize - Issue size of the product. 8</p>
 *,<p>CurrencyId > String (char[]) nominalCurrencyId - Currency in which the product is denominated (three-letter code). 3</p>
 *,<p>UsIndicator usIndicator - US Regulation S indicator. 1</p>
 */
class FinancialProductShare extends ByteSerializable {

    private final Header header;
    private final long productId;
    private final String productIdentification;
    private final String productName;
    private final long productIdentificationTypeId;
    private final long productUnderlyingId;
    private final long financialProductIssuerId;
    private final String financialProductCfi;
    private final String financialProductFisn;
    private final NominalValueType nominalValueType;
    private final long financialProductNominalValue;
    private final IssueSizeType issueSizeType;
    private final BigInteger financialProductIssueSize;
    private final String nominalCurrencyId;
    private final UsIndicator usIndicator;
    private final int byteLength = 205;

    FinancialProductShare(Header header, long productId, String productIdentification, String productName, long productIdentificationTypeId, long productUnderlyingId, long financialProductIssuerId, String financialProductCfi, String financialProductFisn, NominalValueType nominalValueType, long financialProductNominalValue, IssueSizeType issueSizeType, BigInteger financialProductIssueSize, String nominalCurrencyId, UsIndicator usIndicator) {
        this.header = header;
        this.productId = productId;
        this.productIdentification = productIdentification;
        this.productName = productName;
        this.productIdentificationTypeId = productIdentificationTypeId;
        this.productUnderlyingId = productUnderlyingId;
        this.financialProductIssuerId = financialProductIssuerId;
        this.financialProductCfi = financialProductCfi;
        this.financialProductFisn = financialProductFisn;
        this.nominalValueType = nominalValueType;
        this.financialProductNominalValue = financialProductNominalValue;
        this.issueSizeType = issueSizeType;
        this.financialProductIssueSize = financialProductIssueSize;
        this.nominalCurrencyId = nominalCurrencyId;
        this.usIndicator = usIndicator;
    }

    FinancialProductShare(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.productId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.productIdentification = Utils.stringFromByteArray(bytes, offset + 30, 50);
        this.productName = Utils.stringFromByteArray(bytes, offset + 80, 50);
        this.productIdentificationTypeId = Utils.uInt32FromByteArray(bytes, offset + 130);
        this.productUnderlyingId = Utils.uInt32FromByteArray(bytes, offset + 134);
        this.financialProductIssuerId = Utils.uInt32FromByteArray(bytes, offset + 138);
        this.financialProductCfi = Utils.stringFromByteArray(bytes, offset + 142, 6);
        this.financialProductFisn = Utils.stringFromByteArray(bytes, offset + 148, 35);
        this.nominalValueType = NominalValueType.getNominalValueType(bytes, offset + 183);
        this.financialProductNominalValue = Utils.int64FromByteArray(bytes, offset + 184);
        this.issueSizeType = IssueSizeType.getIssueSizeType(bytes, offset + 192);
        this.financialProductIssueSize = Utils.uInt64FromByteArray(bytes, offset + 193);
        this.nominalCurrencyId = Utils.stringFromByteArray(bytes, offset + 201, 3);
        this.usIndicator = UsIndicator.getUsIndicator(bytes, offset + 204);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.productId);
        buffer.put(Utils.stringToByteArray(this.productIdentification, 50));
        buffer.put(Utils.stringToByteArray(this.productName, 50));
        buffer.putLong(this.productIdentificationTypeId);
        buffer.putLong(this.productUnderlyingId);
        buffer.putLong(this.financialProductIssuerId);
        buffer.put(Utils.stringToByteArray(this.financialProductCfi, 6));
        buffer.put(Utils.stringToByteArray(this.financialProductFisn, 35));
        nominalValueType.toBytes(buffer);
        buffer.put(Utils.int64ToByteArray(this.financialProductNominalValue));
        issueSizeType.toBytes(buffer);
        buffer.put(Utils.uInt64ToByteArray(this.financialProductIssueSize));
        buffer.put(Utils.stringToByteArray(this.nominalCurrencyId, 3));
        usIndicator.toBytes(buffer);
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.productId);
        buffer.put(Utils.stringToByteArray(this.productIdentification, 50));
        buffer.put(Utils.stringToByteArray(this.productName, 50));
        buffer.putLong(this.productIdentificationTypeId);
        buffer.putLong(this.productUnderlyingId);
        buffer.putLong(this.financialProductIssuerId);
        buffer.put(Utils.stringToByteArray(this.financialProductCfi, 6));
        buffer.put(Utils.stringToByteArray(this.financialProductFisn, 35));
        nominalValueType.toBytes(buffer);
        buffer.put(Utils.int64ToByteArray(this.financialProductNominalValue));
        issueSizeType.toBytes(buffer);
        buffer.put(Utils.uInt64ToByteArray(this.financialProductIssueSize));
        buffer.put(Utils.stringToByteArray(this.nominalCurrencyId, 3));
        usIndicator.toBytes(buffer);
    }

}




/**
 * <h2>Heartbeat</h2>
 * <p>A message type used to check connectivity.</p>
 * <p>Byte length: 26</p>
 * <p>Header header - Message header. 26</p>
 */
class Heartbeat extends ByteSerializable {

    private final Header header;
    private final int byteLength = 26;

    Heartbeat(Header header) {
        this.header = header;
    }

    Heartbeat(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
    }

}




/**
 * <h2>MarketOperator</h2>
 * <p>List of defined market operators.</p>
 * <p>Byte length: 214</p>
 * <p>Header header - Message header. 26</p>
 *,<p>MarketOperatorId > long (u32) marketOperatorId - ID of the market operator. 4</p>
 *,<p>MicCode > String (char[]) marketOperatorOperatingMIC - Market operator's Market Identifier Code (MIC) as specified in ISO 10383. 4</p>
 *,<p>MarketOperatorName > String (char[]) marketOperatorName - Name of the market operator. 150</p>
 *,<p>LeiCode > String (char[]) marketOperatorLei - Market operator's Legal Entity Identifier as specified in ISO 17422. 20</p>
 *,<p>BicCode > String (char[]) marketOperatorBIC - BIC of the market operator. 8</p>
 *,<p>CountryId > String (char[]) countryId - Market operator's country of registration (two-letter country code). 2</p>
 */
class MarketOperator extends ByteSerializable {

    private final Header header;
    private final long marketOperatorId;
    private final String marketOperatorOperatingMIC;
    private final String marketOperatorName;
    private final String marketOperatorLei;
    private final String marketOperatorBIC;
    private final String countryId;
    private final int byteLength = 214;

    MarketOperator(Header header, long marketOperatorId, String marketOperatorOperatingMIC, String marketOperatorName, String marketOperatorLei, String marketOperatorBIC, String countryId) {
        this.header = header;
        this.marketOperatorId = marketOperatorId;
        this.marketOperatorOperatingMIC = marketOperatorOperatingMIC;
        this.marketOperatorName = marketOperatorName;
        this.marketOperatorLei = marketOperatorLei;
        this.marketOperatorBIC = marketOperatorBIC;
        this.countryId = countryId;
    }

    MarketOperator(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.marketOperatorId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.marketOperatorOperatingMIC = Utils.stringFromByteArray(bytes, offset + 30, 4);
        this.marketOperatorName = Utils.stringFromByteArray(bytes, offset + 34, 150);
        this.marketOperatorLei = Utils.stringFromByteArray(bytes, offset + 184, 20);
        this.marketOperatorBIC = Utils.stringFromByteArray(bytes, offset + 204, 8);
        this.countryId = Utils.stringFromByteArray(bytes, offset + 212, 2);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.marketOperatorId);
        buffer.put(Utils.stringToByteArray(this.marketOperatorOperatingMIC, 4));
        buffer.put(Utils.stringToByteArray(this.marketOperatorName, 150));
        buffer.put(Utils.stringToByteArray(this.marketOperatorLei, 20));
        buffer.put(Utils.stringToByteArray(this.marketOperatorBIC, 8));
        buffer.put(Utils.stringToByteArray(this.countryId, 2));
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.marketOperatorId);
        buffer.put(Utils.stringToByteArray(this.marketOperatorOperatingMIC, 4));
        buffer.put(Utils.stringToByteArray(this.marketOperatorName, 150));
        buffer.put(Utils.stringToByteArray(this.marketOperatorLei, 20));
        buffer.put(Utils.stringToByteArray(this.marketOperatorBIC, 8));
        buffer.put(Utils.stringToByteArray(this.countryId, 2));
    }

}




/**
 * <h2>MarketSegment</h2>
 * <p>List of defined market segments.</p>
 * <p>Byte length: 97</p>
 * <p>Header header - Message header. 26</p>
 *,<p>MarketSegmentId > long (u32) marketSegmentId - ID of the market segment. 4</p>
 *,<p>MarketSegmentId > long (u32) marketSegmentParentId - ID of the parent market segment.
When there's no parent market segment, the value is set to 0. 4</p>
 *,<p>MarketSegmentName > String (char[]) marketSegmentName - Market segment name. 50</p>
 *,<p>MicCode > String (char[]) marketSegmentMic - Market segment's Market Identifier Code (MIC) as specified in ISO 10383. 4</p>
 *,<p>BboDepth > int (u8) marketSegmentBboDepth - Number of price levels published for a given market segment. 1</p>
 *,<p>MarketSegmentTypeId > long (u32) marketSegmentTypeId - ID of the market segment type. 4</p>
 *,<p>TradingVenueId > long (u32) tradingVenueId - ID of the trading venue. 4</p>
 */
class MarketSegment extends ByteSerializable {

    private final Header header;
    private final long marketSegmentId;
    private final long marketSegmentParentId;
    private final String marketSegmentName;
    private final String marketSegmentMic;
    private final int marketSegmentBboDepth;
    private final long marketSegmentTypeId;
    private final long tradingVenueId;
    private final int byteLength = 97;

    MarketSegment(Header header, long marketSegmentId, long marketSegmentParentId, String marketSegmentName, String marketSegmentMic, int marketSegmentBboDepth, long marketSegmentTypeId, long tradingVenueId) {
        this.header = header;
        this.marketSegmentId = marketSegmentId;
        this.marketSegmentParentId = marketSegmentParentId;
        this.marketSegmentName = marketSegmentName;
        this.marketSegmentMic = marketSegmentMic;
        this.marketSegmentBboDepth = marketSegmentBboDepth;
        this.marketSegmentTypeId = marketSegmentTypeId;
        this.tradingVenueId = tradingVenueId;
    }

    MarketSegment(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.marketSegmentId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.marketSegmentParentId = Utils.uInt32FromByteArray(bytes, offset + 30);
        this.marketSegmentName = Utils.stringFromByteArray(bytes, offset + 34, 50);
        this.marketSegmentMic = Utils.stringFromByteArray(bytes, offset + 84, 4);
        this.marketSegmentBboDepth = Utils.uInt8FromByteArray(bytes, offset + 88);
        this.marketSegmentTypeId = Utils.uInt32FromByteArray(bytes, offset + 89);
        this.tradingVenueId = Utils.uInt32FromByteArray(bytes, offset + 93);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.marketSegmentId);
        buffer.putLong(this.marketSegmentParentId);
        buffer.put(Utils.stringToByteArray(this.marketSegmentName, 50));
        buffer.put(Utils.stringToByteArray(this.marketSegmentMic, 4));
        buffer.putInt(this.marketSegmentBboDepth);
        buffer.putLong(this.marketSegmentTypeId);
        buffer.putLong(this.tradingVenueId);
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.marketSegmentId);
        buffer.putLong(this.marketSegmentParentId);
        buffer.put(Utils.stringToByteArray(this.marketSegmentName, 50));
        buffer.put(Utils.stringToByteArray(this.marketSegmentMic, 4));
        buffer.putInt(this.marketSegmentBboDepth);
        buffer.putLong(this.marketSegmentTypeId);
        buffer.putLong(this.tradingVenueId);
    }

}




/**
 * <h2>MarketSegmentPriceLevelConfig</h2>
 * <p>Message used to configure the depth of price level snapshots published by OMD BBO.</p>
 * <p>Byte length: 31</p>
 * <p>Header header - Message header. 26</p>
 *,<p>MarketSegmentId > long (u32) marketSegmentId - ID of the market segment being configured. 4</p>
 *,<p>SnapshotDepth > int (u8) snapshotDepth - Number of price levels to be published for a given market segment, max=10. 1</p>
 */
class MarketSegmentPriceLevelConfig extends ByteSerializable {

    private final Header header;
    private final long marketSegmentId;
    private final int snapshotDepth;
    private final int byteLength = 31;

    MarketSegmentPriceLevelConfig(Header header, long marketSegmentId, int snapshotDepth) {
        this.header = header;
        this.marketSegmentId = marketSegmentId;
        this.snapshotDepth = snapshotDepth;
    }

    MarketSegmentPriceLevelConfig(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.marketSegmentId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.snapshotDepth = Utils.uInt8FromByteArray(bytes, offset + 30);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.marketSegmentId);
        buffer.putInt(this.snapshotDepth);
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.marketSegmentId);
        buffer.putInt(this.snapshotDepth);
    }

}




/**
 * <h2>MarketSegmentType</h2>
 * <p>List of defined market segment types.</p>
 * <p>Byte length: 80</p>
 * <p>Header header - Message header. 26</p>
 *,<p>MarketSegmentTypeId > long (u32) marketSegmentTypeId - ID of the market segment type. 4</p>
 *,<p>MarketSegmentTypeName > String (char[]) marketSegmentTypeName - Name of the type of market segment. 50</p>
 */
class MarketSegmentType extends ByteSerializable {

    private final Header header;
    private final long marketSegmentTypeId;
    private final String marketSegmentTypeName;
    private final int byteLength = 80;

    MarketSegmentType(Header header, long marketSegmentTypeId, String marketSegmentTypeName) {
        this.header = header;
        this.marketSegmentTypeId = marketSegmentTypeId;
        this.marketSegmentTypeName = marketSegmentTypeName;
    }

    MarketSegmentType(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.marketSegmentTypeId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.marketSegmentTypeName = Utils.stringFromByteArray(bytes, offset + 30, 50);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.marketSegmentTypeId);
        buffer.put(Utils.stringToByteArray(this.marketSegmentTypeName, 50));
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.marketSegmentTypeId);
        buffer.put(Utils.stringToByteArray(this.marketSegmentTypeName, 50));
    }

}




/**
 * <h2>OrderAdd</h2>
 * <p>Message used to add new orders to the system.</p>
 * <p>Byte length: 55</p>
 * <p>Header header - Message header. 26</p>
 *,<p>OrderId > BigInteger (u64) orderId - ID of the order being added. 8</p>
 *,<p>TradableProductId > long (u32) tradableProductId - ID of the tradable product in the order being added. 4</p>
 *,<p>OrderSide side - Side (buy/sell) of the order being added. 1</p>
 *,<p>Price > long (i64) price - Price of the order being added. 8</p>
 *,<p>Quantity > BigInteger (u64) quantity - Quantity of the order being added. 8</p>
 */
class OrderAdd extends ByteSerializable {

    private final Header header;
    private final BigInteger orderId;
    private final long tradableProductId;
    private final OrderSide side;
    private final long price;
    private final BigInteger quantity;
    private final int byteLength = 55;

    OrderAdd(Header header, BigInteger orderId, long tradableProductId, OrderSide side, long price, BigInteger quantity) {
        this.header = header;
        this.orderId = orderId;
        this.tradableProductId = tradableProductId;
        this.side = side;
        this.price = price;
        this.quantity = quantity;
    }

    OrderAdd(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.orderId = Utils.uInt64FromByteArray(bytes, offset + 26);
        this.tradableProductId = Utils.uInt32FromByteArray(bytes, offset + 34);
        this.side = OrderSide.getOrderSide(bytes, offset + 38);
        this.price = Utils.int64FromByteArray(bytes, offset + 39);
        this.quantity = Utils.uInt64FromByteArray(bytes, offset + 47);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.put(Utils.uInt64ToByteArray(this.orderId));
        buffer.putLong(this.tradableProductId);
        side.toBytes(buffer);
        buffer.put(Utils.int64ToByteArray(this.price));
        buffer.put(Utils.uInt64ToByteArray(this.quantity));
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.put(Utils.uInt64ToByteArray(this.orderId));
        buffer.putLong(this.tradableProductId);
        side.toBytes(buffer);
        buffer.put(Utils.int64ToByteArray(this.price));
        buffer.put(Utils.uInt64ToByteArray(this.quantity));
    }

}




/**
 * <h2>OrderCollarTableEntry</h2>
 * <p>Message containing an entry into the collars table for orders.</p>
 * <p>Byte length: 71</p>
 * <p>Header header - Message header. 26</p>
 *,<p>CollarTableId > long (u32) collarTableId - Collar table ID. 4</p>
 *,<p>CollarExpression collarExpression - Collar expression type. 1</p>
 *,<p>CollarBound > long (i64) collarLowerBound - Collar lower bound. 8</p>
 *,<p>CollarBound > long (i64) collarLowerBid - Lower collar for bids. 8</p>
 *,<p>CollarBound > long (i64) collarLowerAsk - Lower collar for asks. 8</p>
 *,<p>CollarBound > long (i64) collarUpperBid - Upper collar for bids. 8</p>
 *,<p>CollarBound > long (i64) collarUpperAsk - Upper collar for asks. 8</p>
 */
class OrderCollarTableEntry extends ByteSerializable {

    private final Header header;
    private final long collarTableId;
    private final CollarExpression collarExpression;
    private final long collarLowerBound;
    private final long collarLowerBid;
    private final long collarLowerAsk;
    private final long collarUpperBid;
    private final long collarUpperAsk;
    private final int byteLength = 71;

    OrderCollarTableEntry(Header header, long collarTableId, CollarExpression collarExpression, long collarLowerBound, long collarLowerBid, long collarLowerAsk, long collarUpperBid, long collarUpperAsk) {
        this.header = header;
        this.collarTableId = collarTableId;
        this.collarExpression = collarExpression;
        this.collarLowerBound = collarLowerBound;
        this.collarLowerBid = collarLowerBid;
        this.collarLowerAsk = collarLowerAsk;
        this.collarUpperBid = collarUpperBid;
        this.collarUpperAsk = collarUpperAsk;
    }

    OrderCollarTableEntry(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.collarTableId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.collarExpression = CollarExpression.getCollarExpression(bytes, offset + 30);
        this.collarLowerBound = Utils.int64FromByteArray(bytes, offset + 31);
        this.collarLowerBid = Utils.int64FromByteArray(bytes, offset + 39);
        this.collarLowerAsk = Utils.int64FromByteArray(bytes, offset + 47);
        this.collarUpperBid = Utils.int64FromByteArray(bytes, offset + 55);
        this.collarUpperAsk = Utils.int64FromByteArray(bytes, offset + 63);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.collarTableId);
        collarExpression.toBytes(buffer);
        buffer.put(Utils.int64ToByteArray(this.collarLowerBound));
        buffer.put(Utils.int64ToByteArray(this.collarLowerBid));
        buffer.put(Utils.int64ToByteArray(this.collarLowerAsk));
        buffer.put(Utils.int64ToByteArray(this.collarUpperBid));
        buffer.put(Utils.int64ToByteArray(this.collarUpperAsk));
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.collarTableId);
        collarExpression.toBytes(buffer);
        buffer.put(Utils.int64ToByteArray(this.collarLowerBound));
        buffer.put(Utils.int64ToByteArray(this.collarLowerBid));
        buffer.put(Utils.int64ToByteArray(this.collarLowerAsk));
        buffer.put(Utils.int64ToByteArray(this.collarUpperBid));
        buffer.put(Utils.int64ToByteArray(this.collarUpperAsk));
    }

}




/**
 * <h2>OrderDelete</h2>
 * <p>Message used to delete existing orders.</p>
 * <p>Byte length: 34</p>
 * <p>Header header - Message header. 26</p>
 *,<p>OrderId > BigInteger (u64) orderId - ID of the order being deleted. 8</p>
 */
class OrderDelete extends ByteSerializable {

    private final Header header;
    private final BigInteger orderId;
    private final int byteLength = 34;

    OrderDelete(Header header, BigInteger orderId) {
        this.header = header;
        this.orderId = orderId;
    }

    OrderDelete(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.orderId = Utils.uInt64FromByteArray(bytes, offset + 26);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.put(Utils.uInt64ToByteArray(this.orderId));
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.put(Utils.uInt64ToByteArray(this.orderId));
    }

}




/**
 * <h2>OrderExecute</h2>
 * <p>A message informing about order execution.</p>
 * <p>Byte length: 66</p>
 * <p>Header header - Message header. 26</p>
 *,<p>TradableProductId > long (u32) tradableProductId - ID of the underlying tradable product. 4</p>
 *,<p>OrderId > BigInteger (u64) orderId - ID of the underlying order. 8</p>
 *,<p>Quantity > BigInteger (u64) quantity - Quantity remaining on the market. 8</p>
 *,<p>TradeId > long (u32) executionId - ID of the underlying trade. 4</p>
 *,<p>Price > long (i64) executionPrice - Price at which the order was executed. 8</p>
 *,<p>Quantity > BigInteger (u64) executionQuantity - Execution quantity. 8</p>
 */
class OrderExecute extends ByteSerializable {

    private final Header header;
    private final long tradableProductId;
    private final BigInteger orderId;
    private final BigInteger quantity;
    private final long executionId;
    private final long executionPrice;
    private final BigInteger executionQuantity;
    private final int byteLength = 66;

    OrderExecute(Header header, long tradableProductId, BigInteger orderId, BigInteger quantity, long executionId, long executionPrice, BigInteger executionQuantity) {
        this.header = header;
        this.tradableProductId = tradableProductId;
        this.orderId = orderId;
        this.quantity = quantity;
        this.executionId = executionId;
        this.executionPrice = executionPrice;
        this.executionQuantity = executionQuantity;
    }

    OrderExecute(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.tradableProductId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.orderId = Utils.uInt64FromByteArray(bytes, offset + 30);
        this.quantity = Utils.uInt64FromByteArray(bytes, offset + 38);
        this.executionId = Utils.uInt32FromByteArray(bytes, offset + 46);
        this.executionPrice = Utils.int64FromByteArray(bytes, offset + 50);
        this.executionQuantity = Utils.uInt64FromByteArray(bytes, offset + 58);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.tradableProductId);
        buffer.put(Utils.uInt64ToByteArray(this.orderId));
        buffer.put(Utils.uInt64ToByteArray(this.quantity));
        buffer.putLong(this.executionId);
        buffer.put(Utils.int64ToByteArray(this.executionPrice));
        buffer.put(Utils.uInt64ToByteArray(this.executionQuantity));
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.tradableProductId);
        buffer.put(Utils.uInt64ToByteArray(this.orderId));
        buffer.put(Utils.uInt64ToByteArray(this.quantity));
        buffer.putLong(this.executionId);
        buffer.put(Utils.int64ToByteArray(this.executionPrice));
        buffer.put(Utils.uInt64ToByteArray(this.executionQuantity));
    }

}




/**
 * <h2>OrderModify</h2>
 * <p>Message used to modify existing orders.</p>
 * <p>Byte length: 51</p>
 * <p>Header header - Message header. 26</p>
 *,<p>OrderId > BigInteger (u64) orderId - ID of the order being modified. 8</p>
 *,<p>Price > long (i64) price - Order price after modification. 8</p>
 *,<p>Quantity > BigInteger (u64) quantity - Order quantity after modification. 8</p>
 *,<p>PriorityFlag priorityFlag - Indicates whether the priority flag is lost or retained after modification. 1</p>
 */
class OrderModify extends ByteSerializable {

    private final Header header;
    private final BigInteger orderId;
    private final long price;
    private final BigInteger quantity;
    private final PriorityFlag priorityFlag;
    private final int byteLength = 51;

    OrderModify(Header header, BigInteger orderId, long price, BigInteger quantity, PriorityFlag priorityFlag) {
        this.header = header;
        this.orderId = orderId;
        this.price = price;
        this.quantity = quantity;
        this.priorityFlag = priorityFlag;
    }

    OrderModify(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.orderId = Utils.uInt64FromByteArray(bytes, offset + 26);
        this.price = Utils.int64FromByteArray(bytes, offset + 34);
        this.quantity = Utils.uInt64FromByteArray(bytes, offset + 42);
        this.priorityFlag = PriorityFlag.getPriorityFlag(bytes, offset + 50);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.put(Utils.uInt64ToByteArray(this.orderId));
        buffer.put(Utils.int64ToByteArray(this.price));
        buffer.put(Utils.uInt64ToByteArray(this.quantity));
        priorityFlag.toBytes(buffer);
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.put(Utils.uInt64ToByteArray(this.orderId));
        buffer.put(Utils.int64ToByteArray(this.price));
        buffer.put(Utils.uInt64ToByteArray(this.quantity));
        priorityFlag.toBytes(buffer);
    }

}




/**
 * <h2>PriceLevelUpdate</h2>
 * <p>Market Data message used to transmit price levels.</p>
 * <p>Byte length: 51</p>
 * <p>Header header - Message header. 26</p>
 *,<p>TradableProductId > long (u32) tradableProductId - Product to which the price level refers. 4</p>
 *,<p>PriceLevelNumber > int (u16) priceLevelNumber - Number of the price level, where 1 is the highest (best price). 2</p>
 *,<p>Price > long (i64) priceLevel - Price level in currency units. 8</p>
 *,<p>Quantity > BigInteger (u64) priceLevelQty - Quantity of securities available at a given price level. 8</p>
 *,<p>OrderSide priceLevelSide - Price level side (buy or sell). 1</p>
 *,<p>OrderCount > int (u16) orderCount - Number of open orders at a given price level. 2</p>
 */
class PriceLevelUpdate extends ByteSerializable {

    private final Header header;
    private final long tradableProductId;
    private final int priceLevelNumber;
    private final long priceLevel;
    private final BigInteger priceLevelQty;
    private final OrderSide priceLevelSide;
    private final int orderCount;
    private final int byteLength = 51;

    PriceLevelUpdate(Header header, long tradableProductId, int priceLevelNumber, long priceLevel, BigInteger priceLevelQty, OrderSide priceLevelSide, int orderCount) {
        this.header = header;
        this.tradableProductId = tradableProductId;
        this.priceLevelNumber = priceLevelNumber;
        this.priceLevel = priceLevel;
        this.priceLevelQty = priceLevelQty;
        this.priceLevelSide = priceLevelSide;
        this.orderCount = orderCount;
    }

    PriceLevelUpdate(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.tradableProductId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.priceLevelNumber = Utils.uInt16FromByteArray(bytes, offset + 30);
        this.priceLevel = Utils.int64FromByteArray(bytes, offset + 32);
        this.priceLevelQty = Utils.uInt64FromByteArray(bytes, offset + 40);
        this.priceLevelSide = OrderSide.getOrderSide(bytes, offset + 48);
        this.orderCount = Utils.uInt16FromByteArray(bytes, offset + 49);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.tradableProductId);
        buffer.putInt(this.priceLevelNumber);
        buffer.put(Utils.int64ToByteArray(this.priceLevel));
        buffer.put(Utils.uInt64ToByteArray(this.priceLevelQty));
        priceLevelSide.toBytes(buffer);
        buffer.putInt(this.orderCount);
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.tradableProductId);
        buffer.putInt(this.priceLevelNumber);
        buffer.put(Utils.int64ToByteArray(this.priceLevel));
        buffer.put(Utils.uInt64ToByteArray(this.priceLevelQty));
        priceLevelSide.toBytes(buffer);
        buffer.putInt(this.orderCount);
    }

}




/**
 * <h2>ProductIdentificationType</h2>
 * <p>List of defined product identification types.</p>
 * <p>Byte length: 80</p>
 * <p>Header header - Message header. 26</p>
 *,<p>ProductIdentificationTypeId > long (u32) productIdentificationTypeId - ID of the product identification type. 4</p>
 *,<p>ProductIdentificationTypeName > String (char[]) productIdentificationTypeName - Name of the product identification type (for example ISIN). 50</p>
 */
class ProductIdentificationType extends ByteSerializable {

    private final Header header;
    private final long productIdentificationTypeId;
    private final String productIdentificationTypeName;
    private final int byteLength = 80;

    ProductIdentificationType(Header header, long productIdentificationTypeId, String productIdentificationTypeName) {
        this.header = header;
        this.productIdentificationTypeId = productIdentificationTypeId;
        this.productIdentificationTypeName = productIdentificationTypeName;
    }

    ProductIdentificationType(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.productIdentificationTypeId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.productIdentificationTypeName = Utils.stringFromByteArray(bytes, offset + 30, 50);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.productIdentificationTypeId);
        buffer.put(Utils.stringToByteArray(this.productIdentificationTypeName, 50));
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.productIdentificationTypeId);
        buffer.put(Utils.stringToByteArray(this.productIdentificationTypeName, 50));
    }

}




/**
 * <h2>Test</h2>
 * <p>A message used to test system operation.</p>
 * <p>Byte length: 58</p>
 * <p>Header header - Message header. 26</p>
 *,<p>Timestamp > BigInteger (u64) timestampA - First Core Bus timestamp. 8</p>
 *,<p>Timestamp > BigInteger (u64) timestampB - Sequencer timestamp. 8</p>
 *,<p>Timestamp > BigInteger (u64) timestampC - Market Data timestamp. 8</p>
 *,<p>Timestamp > BigInteger (u64) timestampD - Consumer timestamp. 8</p>
 */
class Test extends ByteSerializable {

    private final Header header;
    private final BigInteger timestampA;
    private final BigInteger timestampB;
    private final BigInteger timestampC;
    private final BigInteger timestampD;
    private final int byteLength = 58;

    Test(Header header, BigInteger timestampA, BigInteger timestampB, BigInteger timestampC, BigInteger timestampD) {
        this.header = header;
        this.timestampA = timestampA;
        this.timestampB = timestampB;
        this.timestampC = timestampC;
        this.timestampD = timestampD;
    }

    Test(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.timestampA = Utils.uInt64FromByteArray(bytes, offset + 26);
        this.timestampB = Utils.uInt64FromByteArray(bytes, offset + 34);
        this.timestampC = Utils.uInt64FromByteArray(bytes, offset + 42);
        this.timestampD = Utils.uInt64FromByteArray(bytes, offset + 50);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.put(Utils.uInt64ToByteArray(this.timestampA));
        buffer.put(Utils.uInt64ToByteArray(this.timestampB));
        buffer.put(Utils.uInt64ToByteArray(this.timestampC));
        buffer.put(Utils.uInt64ToByteArray(this.timestampD));
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.put(Utils.uInt64ToByteArray(this.timestampA));
        buffer.put(Utils.uInt64ToByteArray(this.timestampB));
        buffer.put(Utils.uInt64ToByteArray(this.timestampC));
        buffer.put(Utils.uInt64ToByteArray(this.timestampD));
    }

}




/**
 * <h2>TestMax</h2>
 * <p>A test message of the maximum size supported by the system.</p>
 * <p>Byte length: 1462</p>
 * <p>Header header - Message header. 26</p>
 *,<p>TestPayload > String (char[]) payload - The largest UDP packet the system can work with. The length is 1500 minus message header size (36 b) minus IP and UDP header sizes (28 b) = 1436. 1436</p>
 */
class TestMax extends ByteSerializable {

    private final Header header;
    private final String payload;
    private final int byteLength = 1462;

    TestMax(Header header, String payload) {
        this.header = header;
        this.payload = payload;
    }

    TestMax(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.payload = Utils.stringFromByteArray(bytes, offset + 26, 1436);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.put(Utils.stringToByteArray(this.payload, 1436));
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.put(Utils.stringToByteArray(this.payload, 1436));
    }

}




/**
 * <h2>Text</h2>
 * <p>A text message.</p>
 * <p>Byte length: 76</p>
 * <p>Header header - Message header. 26</p>
 *,<p>TextMessage > String (char[]) text - Arbitrary text. 50</p>
 */
class Text extends ByteSerializable {

    private final Header header;
    private final String text;
    private final int byteLength = 76;

    Text(Header header, String text) {
        this.header = header;
        this.text = text;
    }

    Text(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.text = Utils.stringFromByteArray(bytes, offset + 26, 50);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.put(Utils.stringToByteArray(this.text, 50));
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.put(Utils.stringToByteArray(this.text, 50));
    }

}




/**
 * <h2>TickTable</h2>
 * <p>undefined</p>
 * <p>Byte length: 131</p>
 * <p>Header header - undefined 26</p>
 *,<p>TickTableId > long (u32) tickTableId - undefined 4</p>
 *,<p>TickTableName > String (char[]) tickTableName - undefined 50</p>
 *,<p>TickTableDescription > String (char[]) tickTableDescription - undefined 50</p>
 *,<p>TickTableType tickTableType - undefined 1</p>
 */
class TickTable extends ByteSerializable {

    private final Header header;
    private final long tickTableId;
    private final String tickTableName;
    private final String tickTableDescription;
    private final TickTableType tickTableType;
    private final int byteLength = 131;

    TickTable(Header header, long tickTableId, String tickTableName, String tickTableDescription, TickTableType tickTableType) {
        this.header = header;
        this.tickTableId = tickTableId;
        this.tickTableName = tickTableName;
        this.tickTableDescription = tickTableDescription;
        this.tickTableType = tickTableType;
    }

    TickTable(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.tickTableId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.tickTableName = Utils.stringFromByteArray(bytes, offset + 30, 50);
        this.tickTableDescription = Utils.stringFromByteArray(bytes, offset + 80, 50);
        this.tickTableType = TickTableType.getTickTableType(bytes, offset + 130);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.tickTableId);
        buffer.put(Utils.stringToByteArray(this.tickTableName, 50));
        buffer.put(Utils.stringToByteArray(this.tickTableDescription, 50));
        tickTableType.toBytes(buffer);
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.tickTableId);
        buffer.put(Utils.stringToByteArray(this.tickTableName, 50));
        buffer.put(Utils.stringToByteArray(this.tickTableDescription, 50));
        tickTableType.toBytes(buffer);
    }

}




/**
 * <h2>TickTableEntry</h2>
 * <p>Message defining tick size.</p>
 * <p>Byte length: 50</p>
 * <p>Header header - Message header. 26</p>
 *,<p>TickTableEntryId > long (u32) tickTableEntryId - Tick size ID. 4</p>
 *,<p>TickTableEntryTickSize > long (i64) tickTableEntryTickSize - A single tick. 8</p>
 *,<p>TickTableEntryLowerBound > long (i64) tickTableEntryLowerBound - Tick size lower bound. 8</p>
 *,<p>TickTableId > long (u32) tickTableId - Tick table ID. 4</p>
 */
class TickTableEntry extends ByteSerializable {

    private final Header header;
    private final long tickTableEntryId;
    private final long tickTableEntryTickSize;
    private final long tickTableEntryLowerBound;
    private final long tickTableId;
    private final int byteLength = 50;

    TickTableEntry(Header header, long tickTableEntryId, long tickTableEntryTickSize, long tickTableEntryLowerBound, long tickTableId) {
        this.header = header;
        this.tickTableEntryId = tickTableEntryId;
        this.tickTableEntryTickSize = tickTableEntryTickSize;
        this.tickTableEntryLowerBound = tickTableEntryLowerBound;
        this.tickTableId = tickTableId;
    }

    TickTableEntry(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.tickTableEntryId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.tickTableEntryTickSize = Utils.int64FromByteArray(bytes, offset + 30);
        this.tickTableEntryLowerBound = Utils.int64FromByteArray(bytes, offset + 38);
        this.tickTableId = Utils.uInt32FromByteArray(bytes, offset + 46);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.tickTableEntryId);
        buffer.put(Utils.int64ToByteArray(this.tickTableEntryTickSize));
        buffer.put(Utils.int64ToByteArray(this.tickTableEntryLowerBound));
        buffer.putLong(this.tickTableId);
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.tickTableEntryId);
        buffer.put(Utils.int64ToByteArray(this.tickTableEntryTickSize));
        buffer.put(Utils.int64ToByteArray(this.tickTableEntryLowerBound));
        buffer.putLong(this.tickTableId);
    }

}




/**
 * <h2>TradableProduct</h2>
 * <p>List of defined tradable products.</p>
 * <p>Byte length: 165</p>
 * <p>Header header - Message header. 26</p>
 *,<p>TradableProductId > long (u32) tradableProductId - ID of the tradable product. 4</p>
 *,<p>TradableProductName > String (char[]) tradableProductName - Name of the tradable product. 50</p>
 *,<p>Date > long (u32) tradableProductFirstTradingDate - First trading date of the tradable product. 4</p>
 *,<p>Date > long (u32) tradableProductLastTradingDate - Last trading date of the tradable product. 4</p>
 *,<p>LotSize > long (u32) tradableProductLotSize - Lot size for the tradable product. 4</p>
 *,<p>TradableProductMinimumIcebergValue > long (i64) tradableProductMinimumIcebergValue - Minimum value for iceberg orders for the tradable product. 8</p>
 *,<p>ProductId > long (u32) productId - ID of the product. 4</p>
 *,<p>TradingGroupId > long (u32) tradingGroupId - ID of the trading group. 4</p>
 *,<p>CurrencyId > String (char[]) tradingCurrencyId - Three-letter ID of the trading currency (e.g. USD). 3</p>
 *,<p>PriceExpressionType priceExpressionType - Price expression type for the tradable product. 1</p>
 *,<p>MarketSegmentId > long (u32) marketSegmentId - ID of the tradable product's market segment. 4</p>
 *,<p>CalendarId > long (u32) calendarId - ID of the trading calendar used for the tradable product. 4</p>
 *,<p>TickTableId > long (u32) tickTableId - ID of the tick table used for the tradable product. 4</p>
 *,<p>PreTradeCheckMaxVolume > long (i64) preTradeCheckMaxVolume - Max volume for pre-trade checks for the tradable product. 8</p>
 *,<p>PreTradeCheckMaxValue > long (i64) preTradeCheckMaxValue - Max value for pre-trade checks for the tradable product. 8</p>
 *,<p>PreTradeCheckMinValue > long (i64) preTradeCheckMinValue - Min value for pre-trade checks for the tradable product. 8</p>
 *,<p>PreTradeCheckMinVolume > long (i64) preTradeCheckMinVolume - Min volume for pre-trade checks for the tradable product. 8</p>
 *,<p>VolumeType maxVolumeType - How max volume is expressed for the tradable product. 1</p>
 *,<p>VolumeType minVolumeType - How min volume is expressed for the tradable product. 1</p>
 *,<p>SettlementCalendarId > long (u32) settlementCalendarId - undefined 4</p>
 *,<p>BboDepth > int (u8) bboDepth - undefined 1</p>
 *,<p>Precision > int (u8) accruedInterestPrecision - undefined 1</p>
 *,<p>Precision > int (u8) valuePrecision - undefined 1</p>
 */
class TradableProduct extends ByteSerializable {

    private final Header header;
    private final long tradableProductId;
    private final String tradableProductName;
    private final long tradableProductFirstTradingDate;
    private final long tradableProductLastTradingDate;
    private final long tradableProductLotSize;
    private final long tradableProductMinimumIcebergValue;
    private final long productId;
    private final long tradingGroupId;
    private final String tradingCurrencyId;
    private final PriceExpressionType priceExpressionType;
    private final long marketSegmentId;
    private final long calendarId;
    private final long tickTableId;
    private final long preTradeCheckMaxVolume;
    private final long preTradeCheckMaxValue;
    private final long preTradeCheckMinValue;
    private final long preTradeCheckMinVolume;
    private final VolumeType maxVolumeType;
    private final VolumeType minVolumeType;
    private final long settlementCalendarId;
    private final int bboDepth;
    private final int accruedInterestPrecision;
    private final int valuePrecision;
    private final int byteLength = 165;

    TradableProduct(Header header, long tradableProductId, String tradableProductName, long tradableProductFirstTradingDate, long tradableProductLastTradingDate, long tradableProductLotSize, long tradableProductMinimumIcebergValue, long productId, long tradingGroupId, String tradingCurrencyId, PriceExpressionType priceExpressionType, long marketSegmentId, long calendarId, long tickTableId, long preTradeCheckMaxVolume, long preTradeCheckMaxValue, long preTradeCheckMinValue, long preTradeCheckMinVolume, VolumeType maxVolumeType, VolumeType minVolumeType, long settlementCalendarId, int bboDepth, int accruedInterestPrecision, int valuePrecision) {
        this.header = header;
        this.tradableProductId = tradableProductId;
        this.tradableProductName = tradableProductName;
        this.tradableProductFirstTradingDate = tradableProductFirstTradingDate;
        this.tradableProductLastTradingDate = tradableProductLastTradingDate;
        this.tradableProductLotSize = tradableProductLotSize;
        this.tradableProductMinimumIcebergValue = tradableProductMinimumIcebergValue;
        this.productId = productId;
        this.tradingGroupId = tradingGroupId;
        this.tradingCurrencyId = tradingCurrencyId;
        this.priceExpressionType = priceExpressionType;
        this.marketSegmentId = marketSegmentId;
        this.calendarId = calendarId;
        this.tickTableId = tickTableId;
        this.preTradeCheckMaxVolume = preTradeCheckMaxVolume;
        this.preTradeCheckMaxValue = preTradeCheckMaxValue;
        this.preTradeCheckMinValue = preTradeCheckMinValue;
        this.preTradeCheckMinVolume = preTradeCheckMinVolume;
        this.maxVolumeType = maxVolumeType;
        this.minVolumeType = minVolumeType;
        this.settlementCalendarId = settlementCalendarId;
        this.bboDepth = bboDepth;
        this.accruedInterestPrecision = accruedInterestPrecision;
        this.valuePrecision = valuePrecision;
    }

    TradableProduct(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.tradableProductId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.tradableProductName = Utils.stringFromByteArray(bytes, offset + 30, 50);
        this.tradableProductFirstTradingDate = Utils.uInt32FromByteArray(bytes, offset + 80);
        this.tradableProductLastTradingDate = Utils.uInt32FromByteArray(bytes, offset + 84);
        this.tradableProductLotSize = Utils.uInt32FromByteArray(bytes, offset + 88);
        this.tradableProductMinimumIcebergValue = Utils.int64FromByteArray(bytes, offset + 92);
        this.productId = Utils.uInt32FromByteArray(bytes, offset + 100);
        this.tradingGroupId = Utils.uInt32FromByteArray(bytes, offset + 104);
        this.tradingCurrencyId = Utils.stringFromByteArray(bytes, offset + 108, 3);
        this.priceExpressionType = PriceExpressionType.getPriceExpressionType(bytes, offset + 111);
        this.marketSegmentId = Utils.uInt32FromByteArray(bytes, offset + 112);
        this.calendarId = Utils.uInt32FromByteArray(bytes, offset + 116);
        this.tickTableId = Utils.uInt32FromByteArray(bytes, offset + 120);
        this.preTradeCheckMaxVolume = Utils.int64FromByteArray(bytes, offset + 124);
        this.preTradeCheckMaxValue = Utils.int64FromByteArray(bytes, offset + 132);
        this.preTradeCheckMinValue = Utils.int64FromByteArray(bytes, offset + 140);
        this.preTradeCheckMinVolume = Utils.int64FromByteArray(bytes, offset + 148);
        this.maxVolumeType = VolumeType.getVolumeType(bytes, offset + 156);
        this.minVolumeType = VolumeType.getVolumeType(bytes, offset + 157);
        this.settlementCalendarId = Utils.uInt32FromByteArray(bytes, offset + 158);
        this.bboDepth = Utils.uInt8FromByteArray(bytes, offset + 162);
        this.accruedInterestPrecision = Utils.uInt8FromByteArray(bytes, offset + 163);
        this.valuePrecision = Utils.uInt8FromByteArray(bytes, offset + 164);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.tradableProductId);
        buffer.put(Utils.stringToByteArray(this.tradableProductName, 50));
        buffer.putLong(this.tradableProductFirstTradingDate);
        buffer.putLong(this.tradableProductLastTradingDate);
        buffer.putLong(this.tradableProductLotSize);
        buffer.put(Utils.int64ToByteArray(this.tradableProductMinimumIcebergValue));
        buffer.putLong(this.productId);
        buffer.putLong(this.tradingGroupId);
        buffer.put(Utils.stringToByteArray(this.tradingCurrencyId, 3));
        priceExpressionType.toBytes(buffer);
        buffer.putLong(this.marketSegmentId);
        buffer.putLong(this.calendarId);
        buffer.putLong(this.tickTableId);
        buffer.put(Utils.int64ToByteArray(this.preTradeCheckMaxVolume));
        buffer.put(Utils.int64ToByteArray(this.preTradeCheckMaxValue));
        buffer.put(Utils.int64ToByteArray(this.preTradeCheckMinValue));
        buffer.put(Utils.int64ToByteArray(this.preTradeCheckMinVolume));
        maxVolumeType.toBytes(buffer);
        minVolumeType.toBytes(buffer);
        buffer.putLong(this.settlementCalendarId);
        buffer.putInt(this.bboDepth);
        buffer.putInt(this.accruedInterestPrecision);
        buffer.putInt(this.valuePrecision);
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.tradableProductId);
        buffer.put(Utils.stringToByteArray(this.tradableProductName, 50));
        buffer.putLong(this.tradableProductFirstTradingDate);
        buffer.putLong(this.tradableProductLastTradingDate);
        buffer.putLong(this.tradableProductLotSize);
        buffer.put(Utils.int64ToByteArray(this.tradableProductMinimumIcebergValue));
        buffer.putLong(this.productId);
        buffer.putLong(this.tradingGroupId);
        buffer.put(Utils.stringToByteArray(this.tradingCurrencyId, 3));
        priceExpressionType.toBytes(buffer);
        buffer.putLong(this.marketSegmentId);
        buffer.putLong(this.calendarId);
        buffer.putLong(this.tickTableId);
        buffer.put(Utils.int64ToByteArray(this.preTradeCheckMaxVolume));
        buffer.put(Utils.int64ToByteArray(this.preTradeCheckMaxValue));
        buffer.put(Utils.int64ToByteArray(this.preTradeCheckMinValue));
        buffer.put(Utils.int64ToByteArray(this.preTradeCheckMinVolume));
        maxVolumeType.toBytes(buffer);
        minVolumeType.toBytes(buffer);
        buffer.putLong(this.settlementCalendarId);
        buffer.putInt(this.bboDepth);
        buffer.putInt(this.accruedInterestPrecision);
        buffer.putInt(this.valuePrecision);
    }

}




/**
 * <h2>TradeCollarTableEntry</h2>
 * <p>Message containing an entry into the collars table for trades.</p>
 * <p>Byte length: 47</p>
 * <p>Header header - Message header. 26</p>
 *,<p>CollarTableId > long (u32) collarTableId - Collar table ID. 4</p>
 *,<p>CollarExpression collarExpression - Collar expression type. 1</p>
 *,<p>CollarBound > long (i64) collarLowerBound - Collar lower bound. 8</p>
 *,<p>CollarValue > long (i64) collarValue - Collar value. 8</p>
 */
class TradeCollarTableEntry extends ByteSerializable {

    private final Header header;
    private final long collarTableId;
    private final CollarExpression collarExpression;
    private final long collarLowerBound;
    private final long collarValue;
    private final int byteLength = 47;

    TradeCollarTableEntry(Header header, long collarTableId, CollarExpression collarExpression, long collarLowerBound, long collarValue) {
        this.header = header;
        this.collarTableId = collarTableId;
        this.collarExpression = collarExpression;
        this.collarLowerBound = collarLowerBound;
        this.collarValue = collarValue;
    }

    TradeCollarTableEntry(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.collarTableId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.collarExpression = CollarExpression.getCollarExpression(bytes, offset + 30);
        this.collarLowerBound = Utils.int64FromByteArray(bytes, offset + 31);
        this.collarValue = Utils.int64FromByteArray(bytes, offset + 39);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.collarTableId);
        collarExpression.toBytes(buffer);
        buffer.put(Utils.int64ToByteArray(this.collarLowerBound));
        buffer.put(Utils.int64ToByteArray(this.collarValue));
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.collarTableId);
        collarExpression.toBytes(buffer);
        buffer.put(Utils.int64ToByteArray(this.collarLowerBound));
        buffer.put(Utils.int64ToByteArray(this.collarValue));
    }

}




/**
 * <h2>TradingConfig</h2>
 * <p>List of defined trading configurations.</p>
 * <p>Byte length: 80</p>
 * <p>Header header - Message header. 26</p>
 *,<p>TradingConfigId > long (u32) tradingConfigId - ID of the trading configuration. 4</p>
 *,<p>TradingConfigName > String (char[]) tradingConfigName - Name of the trading configuration. 50</p>
 */
class TradingConfig extends ByteSerializable {

    private final Header header;
    private final long tradingConfigId;
    private final String tradingConfigName;
    private final int byteLength = 80;

    TradingConfig(Header header, long tradingConfigId, String tradingConfigName) {
        this.header = header;
        this.tradingConfigId = tradingConfigId;
        this.tradingConfigName = tradingConfigName;
    }

    TradingConfig(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.tradingConfigId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.tradingConfigName = Utils.stringFromByteArray(bytes, offset + 30, 50);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.tradingConfigId);
        buffer.put(Utils.stringToByteArray(this.tradingConfigName, 50));
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.tradingConfigId);
        buffer.put(Utils.stringToByteArray(this.tradingConfigName, 50));
    }

}




/**
 * <h2>TradingGroup</h2>
 * <p>List of defined trading groups.</p>
 * <p>Byte length: 84</p>
 * <p>Header header - Message header. 26</p>
 *,<p>TradingGroupId > long (u32) tradingGroupId - ID of the trading group. 4</p>
 *,<p>MarketSegmentId > long (u32) marketSegmentId - ID of the market segment. 4</p>
 *,<p>TradingGroupName > String (char[]) tradingGroupName - Name of the trading group. 50</p>
 */
class TradingGroup extends ByteSerializable {

    private final Header header;
    private final long tradingGroupId;
    private final long marketSegmentId;
    private final String tradingGroupName;
    private final int byteLength = 84;

    TradingGroup(Header header, long tradingGroupId, long marketSegmentId, String tradingGroupName) {
        this.header = header;
        this.tradingGroupId = tradingGroupId;
        this.marketSegmentId = marketSegmentId;
        this.tradingGroupName = tradingGroupName;
    }

    TradingGroup(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.tradingGroupId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.marketSegmentId = Utils.uInt32FromByteArray(bytes, offset + 30);
        this.tradingGroupName = Utils.stringFromByteArray(bytes, offset + 34, 50);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.tradingGroupId);
        buffer.putLong(this.marketSegmentId);
        buffer.put(Utils.stringToByteArray(this.tradingGroupName, 50));
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.tradingGroupId);
        buffer.putLong(this.marketSegmentId);
        buffer.put(Utils.stringToByteArray(this.tradingGroupName, 50));
    }

}




/**
 * <h2>TradingVenue</h2>
 * <p>List of defined trading venues.</p>
 * <p>Byte length: 88</p>
 * <p>Header header - Message header. 26</p>
 *,<p>TradingVenueId > long (u32) tradingVenueId - ID of the trading venue. 4</p>
 *,<p>MicCode > String (char[]) tradingVenueMic - Trading venue's Market Identifier Code (MIC) as specified in ISO 10383. 4</p>
 *,<p>TradingVenueName > String (char[]) tradingVenueName - Name of the trading venue. 50</p>
 *,<p>MarketOperatorId > long (u32) marketOperatorId - ID of the market operator. 4</p>
 */
class TradingVenue extends ByteSerializable {

    private final Header header;
    private final long tradingVenueId;
    private final String tradingVenueMic;
    private final String tradingVenueName;
    private final long marketOperatorId;
    private final int byteLength = 88;

    TradingVenue(Header header, long tradingVenueId, String tradingVenueMic, String tradingVenueName, long marketOperatorId) {
        this.header = header;
        this.tradingVenueId = tradingVenueId;
        this.tradingVenueMic = tradingVenueMic;
        this.tradingVenueName = tradingVenueName;
        this.marketOperatorId = marketOperatorId;
    }

    TradingVenue(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.tradingVenueId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.tradingVenueMic = Utils.stringFromByteArray(bytes, offset + 30, 4);
        this.tradingVenueName = Utils.stringFromByteArray(bytes, offset + 34, 50);
        this.marketOperatorId = Utils.uInt32FromByteArray(bytes, offset + 84);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.tradingVenueId);
        buffer.put(Utils.stringToByteArray(this.tradingVenueMic, 4));
        buffer.put(Utils.stringToByteArray(this.tradingVenueName, 50));
        buffer.putLong(this.marketOperatorId);
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.tradingVenueId);
        buffer.put(Utils.stringToByteArray(this.tradingVenueMic, 4));
        buffer.put(Utils.stringToByteArray(this.tradingVenueName, 50));
        buffer.putLong(this.marketOperatorId);
    }

}




/**
 * <h2>WeekPlan</h2>
 * <p>Message containing a week plan (trading schedule).</p>
 * <p>Byte length: 36</p>
 * <p>Header header - Message header. 26</p>
 *,<p>WeekPlanId > long (u32) weekPlanId - Week plan ID. 4</p>
 *,<p>DayOfWeek dayOfWeek - Day of week. 1</p>
 *,<p>DayStatus dayStatus - Day status. 1</p>
 *,<p>CalendarId > long (u32) calendarId - Calendar ID. 4</p>
 */
class WeekPlan extends ByteSerializable {

    private final Header header;
    private final long weekPlanId;
    private final DayOfWeek dayOfWeek;
    private final DayStatus dayStatus;
    private final long calendarId;
    private final int byteLength = 36;

    WeekPlan(Header header, long weekPlanId, DayOfWeek dayOfWeek, DayStatus dayStatus, long calendarId) {
        this.header = header;
        this.weekPlanId = weekPlanId;
        this.dayOfWeek = dayOfWeek;
        this.dayStatus = dayStatus;
        this.calendarId = calendarId;
    }

    WeekPlan(byte[] bytes, int offset) {
        this.header = new Header(bytes, offset);
        this.weekPlanId = Utils.uInt32FromByteArray(bytes, offset + 26);
        this.dayOfWeek = DayOfWeek.getDayOfWeek(bytes, offset + 30);
        this.dayStatus = DayStatus.getDayStatus(bytes, offset + 31);
        this.calendarId = Utils.uInt32FromByteArray(bytes, offset + 32);
    }


    @Override  
    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        header.toBytes(buffer);
        buffer.putLong(this.weekPlanId);
        dayOfWeek.toBytes(buffer);
        dayStatus.toBytes(buffer);
        buffer.putLong(this.calendarId);
        return buffer.array();
    }

    @Override  
    void toBytes(ByteBuffer buffer) {
        header.toBytes(buffer);
        buffer.putLong(this.weekPlanId);
        dayOfWeek.toBytes(buffer);
        dayStatus.toBytes(buffer);
        buffer.putLong(this.calendarId);
    }

}



/**
 * Enum: MsgType
 * undefined
 */
public enum MsgType {


    HEARTBEAT(1),
    TEXT(2),
    TEST(3),
    TESTMAX(8),
    ORDERADD(9),
    ORDERMODIFY(10),
    ORDERDELETE(11),
    ORDEREXECUTE(12),
    BUSINESSCLASSIFICATIONTREE(13),
    COUNTRY(14),
    FINANCIALPRODUCTISSUER(15),
    MARKETOPERATOR(16),
    TRADINGVENUE(17),
    MARKETSEGMENTTYPE(18),
    TRADINGCONFIG(19),
    MARKETSEGMENT(20),
    FINANCIALPRODUCTCLASSIFICATIONTREE(21),
    TRADINGGROUP(22),
    FINANCIALPRODUCTSHARE(23),
    PRODUCTIDENTIFICATIONTYPE(24),
    CURRENCY(25),
    TRADABLEPRODUCT(26),
    BUSINESSCLASSIFICATIONMETHOD(27),
    FINANCIALPRODUCTISSUERBUSINESSCLASSIFICATION(28),
    FINANCIALPRODUCTBOND(29),
    FINANCIALPRODUCTCLASSIFICATIONMETHOD(30),
    FINANCIALPRODUCTCLASSIFICATION(31),
    TICKTABLEENTRY(32),
    TICKTABLE(33),
    CALENDAR(34),
    CALENDAREXCEPTION(35),
    PRICELEVELUPDATE(256),
    MARKETSEGMENTPRICELEVELCONFIG(258),
    COLLARTABLE(259),
    ORDERCOLLARTABLEENTRY(260),
    TRADECOLLARTABLEENTRY(261),
    WEEKPLAN(666),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 2;


    private static Map<Integer, MsgType> TYPES = new HashMap<>();
    static {
        for (MsgType type : MsgType.values()) {
            TYPES.put(type.value, type);
        }
    }


    MsgType(int newValue) {
        value = newValue;
    }

    /**
     Get MsgType from java input
     * @param newValue
     * @return MsgType enum
     */
    public static MsgType getMsgType(int newValue) {
        MsgType val = TYPES.get(newValue);
        return val == null ? MsgType.UNKNOWN : val;
    }

    /**
     Get MsgType from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static MsgType getMsgType(byte[] bytes, int offset) {
        return getMsgType(Utils.uInt16FromByteArray(bytes, offset));
    }

    /**
     * Get MsgType int value
     * @return int value
     */
    public int getMsgTypeValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}









































































































































































































































































































































/**
 * Enum: AccountType
 * Account type.
 */
public enum AccountType {


    MISSING(1),
    CUSTOMER(2),
    HOUSE(3),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, AccountType> TYPES = new HashMap<>();
    static {
        for (AccountType type : AccountType.values()) {
            TYPES.put(type.value, type);
        }
    }


    AccountType(int newValue) {
        value = newValue;
    }

    /**
     Get AccountType from java input
     * @param newValue
     * @return MsgType enum
     */
    public static AccountType getAccountType(int newValue) {
        AccountType val = TYPES.get(newValue);
        return val == null ? AccountType.UNKNOWN : val;
    }

    /**
     Get AccountType from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static AccountType getAccountType(byte[] bytes, int offset) {
        return getAccountType(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get AccountType int value
     * @return int value
     */
    public int getAccountTypeValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: AuctionType
 * undefined
 */
public enum AuctionType {


    AUCTION(1),
    CLOSINGAUCTION(2),
    SUSPENSIONLIFTAUCTION(3),
    VOLATILITYAUCTIONSTATIC(4),
    VOLATILITYAUCTIONDYNAMIC(5),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, AuctionType> TYPES = new HashMap<>();
    static {
        for (AuctionType type : AuctionType.values()) {
            TYPES.put(type.value, type);
        }
    }


    AuctionType(int newValue) {
        value = newValue;
    }

    /**
     Get AuctionType from java input
     * @param newValue
     * @return MsgType enum
     */
    public static AuctionType getAuctionType(int newValue) {
        AuctionType val = TYPES.get(newValue);
        return val == null ? AuctionType.UNKNOWN : val;
    }

    /**
     Get AuctionType from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static AuctionType getAuctionType(byte[] bytes, int offset) {
        return getAuctionType(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get AuctionType int value
     * @return int value
     */
    public int getAuctionTypeValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: CalendarExceptionType
 * Calendar exception type.
 */
public enum CalendarExceptionType {


    HALFDAY(1),
    CLOSED(2),
    OPEN(3),
    TECHNICAL(4),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, CalendarExceptionType> TYPES = new HashMap<>();
    static {
        for (CalendarExceptionType type : CalendarExceptionType.values()) {
            TYPES.put(type.value, type);
        }
    }


    CalendarExceptionType(int newValue) {
        value = newValue;
    }

    /**
     Get CalendarExceptionType from java input
     * @param newValue
     * @return MsgType enum
     */
    public static CalendarExceptionType getCalendarExceptionType(int newValue) {
        CalendarExceptionType val = TYPES.get(newValue);
        return val == null ? CalendarExceptionType.UNKNOWN : val;
    }

    /**
     Get CalendarExceptionType from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static CalendarExceptionType getCalendarExceptionType(byte[] bytes, int offset) {
        return getCalendarExceptionType(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get CalendarExceptionType int value
     * @return int value
     */
    public int getCalendarExceptionTypeValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: ClearingIdentifier
 * Clearing identifier type.
 */
public enum ClearingIdentifier {


    LEI(1),
    BIC(2),
    CUSTOM(3),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, ClearingIdentifier> TYPES = new HashMap<>();
    static {
        for (ClearingIdentifier type : ClearingIdentifier.values()) {
            TYPES.put(type.value, type);
        }
    }


    ClearingIdentifier(int newValue) {
        value = newValue;
    }

    /**
     Get ClearingIdentifier from java input
     * @param newValue
     * @return MsgType enum
     */
    public static ClearingIdentifier getClearingIdentifier(int newValue) {
        ClearingIdentifier val = TYPES.get(newValue);
        return val == null ? ClearingIdentifier.UNKNOWN : val;
    }

    /**
     Get ClearingIdentifier from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static ClearingIdentifier getClearingIdentifier(byte[] bytes, int offset) {
        return getClearingIdentifier(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get ClearingIdentifier int value
     * @return int value
     */
    public int getClearingIdentifierValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: CollarExpression
 * Collar expression type.
 */
public enum CollarExpression {


    PERCENTAGE(1),
    ABSOLUTEVALUE(2),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, CollarExpression> TYPES = new HashMap<>();
    static {
        for (CollarExpression type : CollarExpression.values()) {
            TYPES.put(type.value, type);
        }
    }


    CollarExpression(int newValue) {
        value = newValue;
    }

    /**
     Get CollarExpression from java input
     * @param newValue
     * @return MsgType enum
     */
    public static CollarExpression getCollarExpression(int newValue) {
        CollarExpression val = TYPES.get(newValue);
        return val == null ? CollarExpression.UNKNOWN : val;
    }

    /**
     Get CollarExpression from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static CollarExpression getCollarExpression(byte[] bytes, int offset) {
        return getCollarExpression(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get CollarExpression int value
     * @return int value
     */
    public int getCollarExpressionValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: CollarMode
 * Collar mode (trade price collar or order price collar).
 */
public enum CollarMode {


    TRADEPRICECOLLAR(1),
    ORDERPRICECOLLAR(2),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, CollarMode> TYPES = new HashMap<>();
    static {
        for (CollarMode type : CollarMode.values()) {
            TYPES.put(type.value, type);
        }
    }


    CollarMode(int newValue) {
        value = newValue;
    }

    /**
     Get CollarMode from java input
     * @param newValue
     * @return MsgType enum
     */
    public static CollarMode getCollarMode(int newValue) {
        CollarMode val = TYPES.get(newValue);
        return val == null ? CollarMode.UNKNOWN : val;
    }

    /**
     Get CollarMode from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static CollarMode getCollarMode(byte[] bytes, int offset) {
        return getCollarMode(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get CollarMode int value
     * @return int value
     */
    public int getCollarModeValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: CollarType
 * undefined
 */
public enum CollarType {


    STATICTRADEPRICECOLLAR(1),
    DYNAMICTRADEPRICECOLLAR(2),
    STATICORDERPRICECOLLAR(3),
    DYNAMICORDERPRICECOLLAR(4),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, CollarType> TYPES = new HashMap<>();
    static {
        for (CollarType type : CollarType.values()) {
            TYPES.put(type.value, type);
        }
    }


    CollarType(int newValue) {
        value = newValue;
    }

    /**
     Get CollarType from java input
     * @param newValue
     * @return MsgType enum
     */
    public static CollarType getCollarType(int newValue) {
        CollarType val = TYPES.get(newValue);
        return val == null ? CollarType.UNKNOWN : val;
    }

    /**
     Get CollarType from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static CollarType getCollarType(byte[] bytes, int offset) {
        return getCollarType(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get CollarType int value
     * @return int value
     */
    public int getCollarTypeValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: CouponType
 * undefined
 */
public enum CouponType {


    ZERO(1),
    FIXED(2),
    FLOATING(3),
    INDEXED(4),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, CouponType> TYPES = new HashMap<>();
    static {
        for (CouponType type : CouponType.values()) {
            TYPES.put(type.value, type);
        }
    }


    CouponType(int newValue) {
        value = newValue;
    }

    /**
     Get CouponType from java input
     * @param newValue
     * @return MsgType enum
     */
    public static CouponType getCouponType(int newValue) {
        CouponType val = TYPES.get(newValue);
        return val == null ? CouponType.UNKNOWN : val;
    }

    /**
     Get CouponType from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static CouponType getCouponType(byte[] bytes, int offset) {
        return getCouponType(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get CouponType int value
     * @return int value
     */
    public int getCouponTypeValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: DayOfWeek
 * Enumeration for week days.
 */
public enum DayOfWeek {


    MONDAY(1),
    TUESDAY(2),
    WEDNESDAY(3),
    THURSDAY(4),
    FRIDAY(5),
    SATURDAY(6),
    SUNDAY(7),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, DayOfWeek> TYPES = new HashMap<>();
    static {
        for (DayOfWeek type : DayOfWeek.values()) {
            TYPES.put(type.value, type);
        }
    }


    DayOfWeek(int newValue) {
        value = newValue;
    }

    /**
     Get DayOfWeek from java input
     * @param newValue
     * @return MsgType enum
     */
    public static DayOfWeek getDayOfWeek(int newValue) {
        DayOfWeek val = TYPES.get(newValue);
        return val == null ? DayOfWeek.UNKNOWN : val;
    }

    /**
     Get DayOfWeek from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static DayOfWeek getDayOfWeek(byte[] bytes, int offset) {
        return getDayOfWeek(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get DayOfWeek int value
     * @return int value
     */
    public int getDayOfWeekValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: DayStatus
 * Day status.
 */
public enum DayStatus {


    OPEN(1),
    CLOSED(2),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, DayStatus> TYPES = new HashMap<>();
    static {
        for (DayStatus type : DayStatus.values()) {
            TYPES.put(type.value, type);
        }
    }


    DayStatus(int newValue) {
        value = newValue;
    }

    /**
     Get DayStatus from java input
     * @param newValue
     * @return MsgType enum
     */
    public static DayStatus getDayStatus(int newValue) {
        DayStatus val = TYPES.get(newValue);
        return val == null ? DayStatus.UNKNOWN : val;
    }

    /**
     Get DayStatus from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static DayStatus getDayStatus(byte[] bytes, int offset) {
        return getDayStatus(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get DayStatus int value
     * @return int value
     */
    public int getDayStatusValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: IssueSizeType
 * Type of issue size.
 */
public enum IssueSizeType {


    QUANTITY(1),
    VALUE(2),
    NOISSUESIZE(3),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, IssueSizeType> TYPES = new HashMap<>();
    static {
        for (IssueSizeType type : IssueSizeType.values()) {
            TYPES.put(type.value, type);
        }
    }


    IssueSizeType(int newValue) {
        value = newValue;
    }

    /**
     Get IssueSizeType from java input
     * @param newValue
     * @return MsgType enum
     */
    public static IssueSizeType getIssueSizeType(int newValue) {
        IssueSizeType val = TYPES.get(newValue);
        return val == null ? IssueSizeType.UNKNOWN : val;
    }

    /**
     Get IssueSizeType from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static IssueSizeType getIssueSizeType(byte[] bytes, int offset) {
        return getIssueSizeType(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get IssueSizeType int value
     * @return int value
     */
    public int getIssueSizeTypeValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: LiquidityFlag
 * undefined
 */
public enum LiquidityFlag {


    YES(1),
    NO(2),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, LiquidityFlag> TYPES = new HashMap<>();
    static {
        for (LiquidityFlag type : LiquidityFlag.values()) {
            TYPES.put(type.value, type);
        }
    }


    LiquidityFlag(int newValue) {
        value = newValue;
    }

    /**
     Get LiquidityFlag from java input
     * @param newValue
     * @return MsgType enum
     */
    public static LiquidityFlag getLiquidityFlag(int newValue) {
        LiquidityFlag val = TYPES.get(newValue);
        return val == null ? LiquidityFlag.UNKNOWN : val;
    }

    /**
     Get LiquidityFlag from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static LiquidityFlag getLiquidityFlag(byte[] bytes, int offset) {
        return getLiquidityFlag(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get LiquidityFlag int value
     * @return int value
     */
    public int getLiquidityFlagValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: MatchingAlgorithm
 * Types of matching algorithms.
 */
public enum MatchingAlgorithm {


    CONTINUOUSPRICETIME(1),
    CONTINUOUSREFPRICETIME(2),
    CONTINUOUSLASTAUCTIONTIME(3),
    AUCTIONPRICETIME(4),
    BLOCKEXACTMATCHING(5),
    NOTRADINGNOTRADING(6),
    SUSPENSIONNOTRADING(7),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, MatchingAlgorithm> TYPES = new HashMap<>();
    static {
        for (MatchingAlgorithm type : MatchingAlgorithm.values()) {
            TYPES.put(type.value, type);
        }
    }


    MatchingAlgorithm(int newValue) {
        value = newValue;
    }

    /**
     Get MatchingAlgorithm from java input
     * @param newValue
     * @return MsgType enum
     */
    public static MatchingAlgorithm getMatchingAlgorithm(int newValue) {
        MatchingAlgorithm val = TYPES.get(newValue);
        return val == null ? MatchingAlgorithm.UNKNOWN : val;
    }

    /**
     Get MatchingAlgorithm from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static MatchingAlgorithm getMatchingAlgorithm(byte[] bytes, int offset) {
        return getMatchingAlgorithm(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get MatchingAlgorithm int value
     * @return int value
     */
    public int getMatchingAlgorithmValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: MifirIdentifier
 * MIFIR identifier types.
 */
public enum MifirIdentifier {


    EUSB(1),
    OEPB(2),
    CVTB(3),
    CVDB(4),
    CRPB(5),
    SHRS(6),
    ETFS(7),
    DPRS(8),
    CRFT(9),
    OTHR(10),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, MifirIdentifier> TYPES = new HashMap<>();
    static {
        for (MifirIdentifier type : MifirIdentifier.values()) {
            TYPES.put(type.value, type);
        }
    }


    MifirIdentifier(int newValue) {
        value = newValue;
    }

    /**
     Get MifirIdentifier from java input
     * @param newValue
     * @return MsgType enum
     */
    public static MifirIdentifier getMifirIdentifier(int newValue) {
        MifirIdentifier val = TYPES.get(newValue);
        return val == null ? MifirIdentifier.UNKNOWN : val;
    }

    /**
     Get MifirIdentifier from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static MifirIdentifier getMifirIdentifier(byte[] bytes, int offset) {
        return getMifirIdentifier(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get MifirIdentifier int value
     * @return int value
     */
    public int getMifirIdentifierValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: NominalValueType
 * Indicates the security's nominal value type.
 */
public enum NominalValueType {


    NONOMINAL(1),
    CONSTANT(2),
    UNKNOWN(3),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, NominalValueType> TYPES = new HashMap<>();
    static {
        for (NominalValueType type : NominalValueType.values()) {
            TYPES.put(type.value, type);
        }
    }


    NominalValueType(int newValue) {
        value = newValue;
    }

    /**
     Get NominalValueType from java input
     * @param newValue
     * @return MsgType enum
     */
    public static NominalValueType getNominalValueType(int newValue) {
        NominalValueType val = TYPES.get(newValue);
        return val == null ? NominalValueType.UNKNOWN : val;
    }

    /**
     Get NominalValueType from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static NominalValueType getNominalValueType(byte[] bytes, int offset) {
        return getNominalValueType(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get NominalValueType int value
     * @return int value
     */
    public int getNominalValueTypeValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: OrderSide
 * Indicates order side (buy or sell).
 */
public enum OrderSide {


    BUY(1),
    SELL(2),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, OrderSide> TYPES = new HashMap<>();
    static {
        for (OrderSide type : OrderSide.values()) {
            TYPES.put(type.value, type);
        }
    }


    OrderSide(int newValue) {
        value = newValue;
    }

    /**
     Get OrderSide from java input
     * @param newValue
     * @return MsgType enum
     */
    public static OrderSide getOrderSide(int newValue) {
        OrderSide val = TYPES.get(newValue);
        return val == null ? OrderSide.UNKNOWN : val;
    }

    /**
     Get OrderSide from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static OrderSide getOrderSide(byte[] bytes, int offset) {
        return getOrderSide(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get OrderSide int value
     * @return int value
     */
    public int getOrderSideValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: ParticipantStatus
 * Participant status.
 */
public enum ParticipantStatus {


    ACTIVE(1),
    SUSPENDED(2),
    DISABLED(3),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, ParticipantStatus> TYPES = new HashMap<>();
    static {
        for (ParticipantStatus type : ParticipantStatus.values()) {
            TYPES.put(type.value, type);
        }
    }


    ParticipantStatus(int newValue) {
        value = newValue;
    }

    /**
     Get ParticipantStatus from java input
     * @param newValue
     * @return MsgType enum
     */
    public static ParticipantStatus getParticipantStatus(int newValue) {
        ParticipantStatus val = TYPES.get(newValue);
        return val == null ? ParticipantStatus.UNKNOWN : val;
    }

    /**
     Get ParticipantStatus from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static ParticipantStatus getParticipantStatus(byte[] bytes, int offset) {
        return getParticipantStatus(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get ParticipantStatus int value
     * @return int value
     */
    public int getParticipantStatusValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: ParticipationType
 * undefined
 */
public enum ParticipationType {


    REGULATEDMARKETMAKER(1),
    ISSUERMARKETMAKER(2),
    AGENCYTRADING(3),
    PRINCIPALTRADING(4),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, ParticipationType> TYPES = new HashMap<>();
    static {
        for (ParticipationType type : ParticipationType.values()) {
            TYPES.put(type.value, type);
        }
    }


    ParticipationType(int newValue) {
        value = newValue;
    }

    /**
     Get ParticipationType from java input
     * @param newValue
     * @return MsgType enum
     */
    public static ParticipationType getParticipationType(int newValue) {
        ParticipationType val = TYPES.get(newValue);
        return val == null ? ParticipationType.UNKNOWN : val;
    }

    /**
     Get ParticipationType from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static ParticipationType getParticipationType(byte[] bytes, int offset) {
        return getParticipationType(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get ParticipationType int value
     * @return int value
     */
    public int getParticipationTypeValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: PermissionType
 * Permission type.
 */
public enum PermissionType {


    VIEWONLY(1),
    BUYONLY(2),
    SELLONLY(3),
    BUYSELL(4),
    PROHIBITED(5),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, PermissionType> TYPES = new HashMap<>();
    static {
        for (PermissionType type : PermissionType.values()) {
            TYPES.put(type.value, type);
        }
    }


    PermissionType(int newValue) {
        value = newValue;
    }

    /**
     Get PermissionType from java input
     * @param newValue
     * @return MsgType enum
     */
    public static PermissionType getPermissionType(int newValue) {
        PermissionType val = TYPES.get(newValue);
        return val == null ? PermissionType.UNKNOWN : val;
    }

    /**
     Get PermissionType from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static PermissionType getPermissionType(byte[] bytes, int offset) {
        return getPermissionType(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get PermissionType int value
     * @return int value
     */
    public int getPermissionTypeValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: PriceExpressionType
 * Price expression type.
 */
public enum PriceExpressionType {


    PRICE(1),
    PERCENTAGE(2),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, PriceExpressionType> TYPES = new HashMap<>();
    static {
        for (PriceExpressionType type : PriceExpressionType.values()) {
            TYPES.put(type.value, type);
        }
    }


    PriceExpressionType(int newValue) {
        value = newValue;
    }

    /**
     Get PriceExpressionType from java input
     * @param newValue
     * @return MsgType enum
     */
    public static PriceExpressionType getPriceExpressionType(int newValue) {
        PriceExpressionType val = TYPES.get(newValue);
        return val == null ? PriceExpressionType.UNKNOWN : val;
    }

    /**
     Get PriceExpressionType from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static PriceExpressionType getPriceExpressionType(byte[] bytes, int offset) {
        return getPriceExpressionType(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get PriceExpressionType int value
     * @return int value
     */
    public int getPriceExpressionTypeValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: PriorityFlag
 * Indicates whether the priority flag was lost or retained.
 */
public enum PriorityFlag {


    LOST(1),
    RETAINED(2),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, PriorityFlag> TYPES = new HashMap<>();
    static {
        for (PriorityFlag type : PriorityFlag.values()) {
            TYPES.put(type.value, type);
        }
    }


    PriorityFlag(int newValue) {
        value = newValue;
    }

    /**
     Get PriorityFlag from java input
     * @param newValue
     * @return MsgType enum
     */
    public static PriorityFlag getPriorityFlag(int newValue) {
        PriorityFlag val = TYPES.get(newValue);
        return val == null ? PriorityFlag.UNKNOWN : val;
    }

    /**
     Get PriorityFlag from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static PriorityFlag getPriorityFlag(byte[] bytes, int offset) {
        return getPriorityFlag(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get PriorityFlag int value
     * @return int value
     */
    public int getPriorityFlagValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: ReferencePriceType
 * undefined
 */
public enum ReferencePriceType {


    MANUALPRICE(1),
    ADJUSTEDCLOSINGPRICE(2),
    REFERENCEADJUSTEDCLOSINGPRICE(3),
    LASTAUCTIONPRICE(4),
    REFERENCELASTAUCTIONPRICE(5),
    LASTTRADEPRICE(6),
    REFERENCELASTTRADEPRICE(7),
    VOLUMEWEIGHTEDAVERAGEPRICE(8),
    REFERENCEVOLUMEWEIGHTEDAVERAGEPRICE(9),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, ReferencePriceType> TYPES = new HashMap<>();
    static {
        for (ReferencePriceType type : ReferencePriceType.values()) {
            TYPES.put(type.value, type);
        }
    }


    ReferencePriceType(int newValue) {
        value = newValue;
    }

    /**
     Get ReferencePriceType from java input
     * @param newValue
     * @return MsgType enum
     */
    public static ReferencePriceType getReferencePriceType(int newValue) {
        ReferencePriceType val = TYPES.get(newValue);
        return val == null ? ReferencePriceType.UNKNOWN : val;
    }

    /**
     Get ReferencePriceType from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static ReferencePriceType getReferencePriceType(byte[] bytes, int offset) {
        return getReferencePriceType(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get ReferencePriceType int value
     * @return int value
     */
    public int getReferencePriceTypeValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: SeniorityBond
 * Type of seniority bond.
 */
public enum SeniorityBond {


    UNKNOWN(1),
    SENIORDEBT(2),
    MEZZANINEDEBT(3),
    SUBORDINATEDDEBT(4),
    JUNIORDEBT(5),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, SeniorityBond> TYPES = new HashMap<>();
    static {
        for (SeniorityBond type : SeniorityBond.values()) {
            TYPES.put(type.value, type);
        }
    }


    SeniorityBond(int newValue) {
        value = newValue;
    }

    /**
     Get SeniorityBond from java input
     * @param newValue
     * @return MsgType enum
     */
    public static SeniorityBond getSeniorityBond(int newValue) {
        SeniorityBond val = TYPES.get(newValue);
        return val == null ? SeniorityBond.UNKNOWN : val;
    }

    /**
     Get SeniorityBond from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static SeniorityBond getSeniorityBond(byte[] bytes, int offset) {
        return getSeniorityBond(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get SeniorityBond int value
     * @return int value
     */
    public int getSeniorityBondValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: SettlementStatus
 * Settlement statuses.
 */
public enum SettlementStatus {


    CLOSED(1),
    OPEN(2),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, SettlementStatus> TYPES = new HashMap<>();
    static {
        for (SettlementStatus type : SettlementStatus.values()) {
            TYPES.put(type.value, type);
        }
    }


    SettlementStatus(int newValue) {
        value = newValue;
    }

    /**
     Get SettlementStatus from java input
     * @param newValue
     * @return MsgType enum
     */
    public static SettlementStatus getSettlementStatus(int newValue) {
        SettlementStatus val = TYPES.get(newValue);
        return val == null ? SettlementStatus.UNKNOWN : val;
    }

    /**
     Get SettlementStatus from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static SettlementStatus getSettlementStatus(byte[] bytes, int offset) {
        return getSettlementStatus(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get SettlementStatus int value
     * @return int value
     */
    public int getSettlementStatusValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: TickTableType
 * Type of tick table.
 */
public enum TickTableType {


    POSITIVE(1),
    NEGATIVE(2),
    SYMMETRICAL(3),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, TickTableType> TYPES = new HashMap<>();
    static {
        for (TickTableType type : TickTableType.values()) {
            TYPES.put(type.value, type);
        }
    }


    TickTableType(int newValue) {
        value = newValue;
    }

    /**
     Get TickTableType from java input
     * @param newValue
     * @return MsgType enum
     */
    public static TickTableType getTickTableType(int newValue) {
        TickTableType val = TYPES.get(newValue);
        return val == null ? TickTableType.UNKNOWN : val;
    }

    /**
     Get TickTableType from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static TickTableType getTickTableType(byte[] bytes, int offset) {
        return getTickTableType(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get TickTableType int value
     * @return int value
     */
    public int getTickTableTypeValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: TradingPhaseType
 * Types of trading phases.
 */
public enum TradingPhaseType {


    CONTINUOUS(1),
    AUCTION(2),
    BLOCK(3),
    NOTRADING(4),
    SUSPENSION(5),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, TradingPhaseType> TYPES = new HashMap<>();
    static {
        for (TradingPhaseType type : TradingPhaseType.values()) {
            TYPES.put(type.value, type);
        }
    }


    TradingPhaseType(int newValue) {
        value = newValue;
    }

    /**
     Get TradingPhaseType from java input
     * @param newValue
     * @return MsgType enum
     */
    public static TradingPhaseType getTradingPhaseType(int newValue) {
        TradingPhaseType val = TYPES.get(newValue);
        return val == null ? TradingPhaseType.UNKNOWN : val;
    }

    /**
     Get TradingPhaseType from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static TradingPhaseType getTradingPhaseType(byte[] bytes, int offset) {
        return getTradingPhaseType(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get TradingPhaseType int value
     * @return int value
     */
    public int getTradingPhaseTypeValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: TradingPortType
 * Type of trading port.
 */
public enum TradingPortType {


    FIXTRADING(1),
    FIXDROPCOPY(2),
    FIXCCP(3),
    BINARYTRADING(4),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, TradingPortType> TYPES = new HashMap<>();
    static {
        for (TradingPortType type : TradingPortType.values()) {
            TYPES.put(type.value, type);
        }
    }


    TradingPortType(int newValue) {
        value = newValue;
    }

    /**
     Get TradingPortType from java input
     * @param newValue
     * @return MsgType enum
     */
    public static TradingPortType getTradingPortType(int newValue) {
        TradingPortType val = TYPES.get(newValue);
        return val == null ? TradingPortType.UNKNOWN : val;
    }

    /**
     Get TradingPortType from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static TradingPortType getTradingPortType(byte[] bytes, int offset) {
        return getTradingPortType(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get TradingPortType int value
     * @return int value
     */
    public int getTradingPortTypeValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: Uncrossing
 * Types of uncrossing.
 */
public enum Uncrossing {


    NO(1),
    YESORVOLATILITYAUCTION(2),
    YESOREXTENDEDVOLATILITYAUCTION(3),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, Uncrossing> TYPES = new HashMap<>();
    static {
        for (Uncrossing type : Uncrossing.values()) {
            TYPES.put(type.value, type);
        }
    }


    Uncrossing(int newValue) {
        value = newValue;
    }

    /**
     Get Uncrossing from java input
     * @param newValue
     * @return MsgType enum
     */
    public static Uncrossing getUncrossing(int newValue) {
        Uncrossing val = TYPES.get(newValue);
        return val == null ? Uncrossing.UNKNOWN : val;
    }

    /**
     Get Uncrossing from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static Uncrossing getUncrossing(byte[] bytes, int offset) {
        return getUncrossing(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get Uncrossing int value
     * @return int value
     */
    public int getUncrossingValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: UsIndicator
 * US Regulation S indicator.
 */
public enum UsIndicator {


    NONE(1),
    REGULATIONS(2),
    REGULATIONSPLUSRULE144A(3),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, UsIndicator> TYPES = new HashMap<>();
    static {
        for (UsIndicator type : UsIndicator.values()) {
            TYPES.put(type.value, type);
        }
    }


    UsIndicator(int newValue) {
        value = newValue;
    }

    /**
     Get UsIndicator from java input
     * @param newValue
     * @return MsgType enum
     */
    public static UsIndicator getUsIndicator(int newValue) {
        UsIndicator val = TYPES.get(newValue);
        return val == null ? UsIndicator.UNKNOWN : val;
    }

    /**
     Get UsIndicator from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static UsIndicator getUsIndicator(byte[] bytes, int offset) {
        return getUsIndicator(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get UsIndicator int value
     * @return int value
     */
    public int getUsIndicatorValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}



/**
 * Enum: VolumeType
 * Type of volume.
 */
public enum VolumeType {


    NOVALUE(1),
    QUANTITY(2),
    PERCENTAGEOFISSUE(3),
  UNKNOWN(99999);

    private final int value;

    private final int byteLength = 1;


    private static Map<Integer, VolumeType> TYPES = new HashMap<>();
    static {
        for (VolumeType type : VolumeType.values()) {
            TYPES.put(type.value, type);
        }
    }


    VolumeType(int newValue) {
        value = newValue;
    }

    /**
     Get VolumeType from java input
     * @param newValue
     * @return MsgType enum
     */
    public static VolumeType getVolumeType(int newValue) {
        VolumeType val = TYPES.get(newValue);
        return val == null ? VolumeType.UNKNOWN : val;
    }

    /**
     Get VolumeType from bytes
     * @param bytes byte[]
     * @param offset - int
     */
    public static VolumeType getVolumeType(byte[] bytes, int offset) {
        return getVolumeType(Utils.uInt8FromByteArray(bytes, offset));
    }

    /**
     * Get VolumeType int value
     * @return int value
     */
    public int getVolumeTypeValue() { return value; }

    byte[] toBytes() {
        ByteBuffer buffer = ByteBuffer.allocate(this.byteLength);
        buffer.putInt(this.value);
        return buffer.array();
    }

    void toBytes(ByteBuffer buffer) {
        buffer.putInt(this.value);
    }


}

