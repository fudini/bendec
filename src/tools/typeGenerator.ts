import * as fs from 'fs'
import { range } from 'lodash'
import { normalizeTypes } from '../utils'
import { TypeDefinition, TypeDefinitionStrict, Field } from '../'
import { Kind, EnumStrict, UnionStrict } from '../types'
import { hexPad } from './utils'

const ENABLE_TYPE_REFERENCES = String(process.env.ENABLE_TYPE_REFERENCES || '').toUpperCase()
const TYPE_REFERENCES_ENABLED = ENABLE_TYPE_REFERENCES == '1' || ENABLE_TYPE_REFERENCES == 'Y'

type TypeMapping = Record<string, string>

type Options = {
  extras?: string[]
  typeMapping?: TypeMapping
  header?: boolean
}

export const defaultOptions = {
  extras: [],
  header: true
}

export const defaultMapping: TypeMapping = {
  'char[]': 'Buffer',
}

const resolveCustomType = (typeMap, key): string => {
  return typeMap[key] === undefined ? key : typeMap[key]
}

const indent = (i: number) => (str: string) => {
  return '                    '.substr(-i) + str
}

const getMembers = (fields: Field[], typeMap: TypeMapping) => {
  return fields.map(field => {
    const key = field.type + (field.length ? '[]' : '')
    const finalTypeName = typeMap[key] || key
    return `  ${field.name}: ${finalTypeName}`
  })
}

const getEnum = ({ name, variants }: EnumStrict) => {
  const variantsFields = variants
    .map(([key, value]) => `  ${key} = ${hexPad(value)},`)
    .join('\n')
  const typeLoopback = TYPE_REFERENCES_ENABLED ? `
export namespace ${name} {
  type NameOfEnum = keyof typeof ${name}
  export const cast = (value: number | string): ${name} => typeof value === 'string' ? getValue(value as any) : (value as ${name})
  export const getValue = (name: NameOfEnum): ${name} => ${name}[name] as any
  export const getName = (value: ${name}): string => ${name}[value] as any
  export const getLabel = (value: ${name}): string => \`\$\{getName(value)\} (value)\`
}` : ``
  return `export enum ${name} {
${variantsFields}
}${typeLoopback}`
}

const getStruct = (typeDef, typeMap: TypeMapping) => {
  const members = getMembers(typeDef.fields, typeMap)
  const exposeFields = members.map(line => {
    let [field, type] = line.split(':')
    let fieldName = field.trim();
    let indent = field.substring(0, field.length - fieldName.length)
    return `  ${indent}export const ${fieldName} = "${type.trim()}"`
  }).join("\n")
  const membersString = members.join('\n')
  const typeLoopback = TYPE_REFERENCES_ENABLED ? `
export namespace ${typeDef.name} {
${exposeFields}
}` : ``;
  return `export interface ${typeDef.name} {
${membersString}
}${typeLoopback}`
}

const getUnion = ({ name, members }: UnionStrict) => {
  const unionMembers = members.join(' | ')
  return `export type ${name} = ${unionMembers}`
}

/**
 * Generate TypeScript interfaces from Bendec types definitions
 */
export const generateString = (
  typesDuck: TypeDefinition[],
  options: Options = defaultOptions
) => {
  const types: TypeDefinitionStrict[] = normalizeTypes(typesDuck)
  const unions = types.filter(({ kind }) => kind == Kind.Union)

  const {
    extras = [],
    typeMapping,
    header = true
  } = { ...defaultOptions, ...options }

  const typeMap: TypeMapping = { ...defaultMapping, ...typeMapping }

  const definitions = types.map(typeDef => {
    const typeName = typeDef.name

    if (typeMap[typeName]) {
      return `export type ${typeName} = ${typeMap[typeName]}`
    }

    if (typeDef.kind === Kind.Primitive) {
      return `export type ${typeName} = number`
    }

    if (typeDef.kind === Kind.Alias) {
      return `export type ${typeName} = ${typeDef.alias}`
    }

    if (typeDef.kind === Kind.Union) {
      return getUnion(typeDef)
    }

    if (typeDef.kind === Kind.Enum) {
      return getEnum(typeDef)
    }

    if (typeDef.kind === Kind.Struct) {
      return getStruct(typeDef, typeMap)
    }

    if (typeDef.kind === Kind.Array) {
      const key = typeDef.type + '[]'
      const finalTypeName = typeMap[key] || key
      return `export type ${typeDef.name} = ${finalTypeName}`
    }
  })

  const result = definitions.join('\n\n')
  const extrasString = extras.join('\n')
  const HEADER = header ? '/** GENERATED BY BENDEC TYPE GENERATOR */\n' : ''

  return `${HEADER}${extrasString}
${result}
`
}

/**
 * Generate TypeScript interfaces from Bender types definitions
 */
export const generate = (types: TypeDefinition[], fileName: string, options?: Options) => {
  const moduleWrapped = generateString(types, options)

  fs.writeFileSync(fileName, moduleWrapped)
  console.log(`WRITTEN: ${fileName}`)
}
